import{E as tn,V as y,M as W,T as de,S as ct,Q as V,a as j,R as nn,P as sn,b as Lt,c as on,d as He,e as Mt,L as Pt,f as Ae,F as Me,g as ne,C as te,h as Y,i as $,j as rn,k as an,D as Ct,l as Pe,I as cn,m as ln,O as Ve,n as It,o as un,B as we,p as dn,q as be,N as hn,r as fn,s as pn,t as le,u as mn,v as Ge,w as gn,x as Tn,y as An,z as ke,A as kt,G as ae,H as wn,J as ce,K as bn,U as Xe,W as yn,X as je,Y as En,Z as Nt,_ as Rn,$ as xn,a0 as Le,a1 as Ot,a2 as _n,a3 as Sn,a4 as Ln,a5 as Mn,a6 as Pn,a7 as Dt,a8 as Cn,a9 as lt,aa as ut,ab as dt,ac as ht,ad as ft,ae as In,af as kn,ag as Ue,ah as Nn,ai as On,aj as xe,ak as Ne,al as _e,am as Dn,an as vn,ao as Fn,ap as Bn,aq as Hn,ar as Gn,as as jn,at as pt,au as Un,av as mt,aw as gt,ax as Tt}from"./three-DqSo6mdQ.js";(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))e(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&e(i)}).observe(document,{childList:!0,subtree:!0});function n(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function e(s){if(s.ep)return;s.ep=!0;const o=n(s);fetch(s.href,o)}})();const At={type:"change"},Oe={type:"start"},wt={type:"end"},Se=new nn,bt=new sn,Kn=Math.cos(70*Lt.DEG2RAD);class zn extends tn{constructor(t,n){super(),this.object=t,this.domElement=n,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new y,this.cursor=new y,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:W.ROTATE,MIDDLE:W.DOLLY,RIGHT:W.PAN},this.touches={ONE:de.ROTATE,TWO:de.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return r.phi},this.getAzimuthalAngle=function(){return r.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(l){l.addEventListener("keydown",Ie),this._domElementKeyEvents=l},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",Ie),this._domElementKeyEvents=null},this.saveState=function(){e.target0.copy(e.target),e.position0.copy(e.object.position),e.zoom0=e.object.zoom},this.reset=function(){e.target.copy(e.target0),e.object.position.copy(e.position0),e.object.zoom=e.zoom0,e.object.updateProjectionMatrix(),e.dispatchEvent(At),e.update(),o=s.NONE},this.update=function(){const l=new y,g=new V().setFromUnitVectors(t.up,new y(0,1,0)),M=g.clone().invert(),O=new y,H=new V,se=new y,K=2*Math.PI;return function(en=null){const rt=e.object.position;l.copy(rt).sub(e.target),l.applyQuaternion(g),r.setFromVector3(l),e.autoRotate&&o===s.NONE&&D(C(en)),e.enableDamping?(r.theta+=a.theta*e.dampingFactor,r.phi+=a.phi*e.dampingFactor):(r.theta+=a.theta,r.phi+=a.phi);let Z=e.minAzimuthAngle,J=e.maxAzimuthAngle;isFinite(Z)&&isFinite(J)&&(Z<-Math.PI?Z+=K:Z>Math.PI&&(Z-=K),J<-Math.PI?J+=K:J>Math.PI&&(J-=K),Z<=J?r.theta=Math.max(Z,Math.min(J,r.theta)):r.theta=r.theta>(Z+J)/2?Math.max(Z,r.theta):Math.min(J,r.theta)),r.phi=Math.max(e.minPolarAngle,Math.min(e.maxPolarAngle,r.phi)),r.makeSafe(),e.enableDamping===!0?e.target.addScaledVector(d,e.dampingFactor):e.target.add(d),e.target.sub(e.cursor),e.target.clampLength(e.minTargetRadius,e.maxTargetRadius),e.target.add(e.cursor);let me=!1;if(e.zoomToCursor&&B||e.object.isOrthographicCamera)r.radius=G(r.radius);else{const ee=r.radius;r.radius=G(r.radius*c),me=ee!=r.radius}if(l.setFromSpherical(r),l.applyQuaternion(M),rt.copy(e.target).add(l),e.object.lookAt(e.target),e.enableDamping===!0?(a.theta*=1-e.dampingFactor,a.phi*=1-e.dampingFactor,d.multiplyScalar(1-e.dampingFactor)):(a.set(0,0,0),d.set(0,0,0)),e.zoomToCursor&&B){let ee=null;if(e.object.isPerspectiveCamera){const ge=l.length();ee=G(ge*c);const Re=ge-ee;e.object.position.addScaledVector(x,Re),e.object.updateMatrixWorld(),me=!!Re}else if(e.object.isOrthographicCamera){const ge=new y(k.x,k.y,0);ge.unproject(e.object);const Re=e.object.zoom;e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/c)),e.object.updateProjectionMatrix(),me=Re!==e.object.zoom;const at=new y(k.x,k.y,0);at.unproject(e.object),e.object.position.sub(at).add(ge),e.object.updateMatrixWorld(),ee=l.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),e.zoomToCursor=!1;ee!==null&&(this.screenSpacePanning?e.target.set(0,0,-1).transformDirection(e.object.matrix).multiplyScalar(ee).add(e.object.position):(Se.origin.copy(e.object.position),Se.direction.set(0,0,-1).transformDirection(e.object.matrix),Math.abs(e.object.up.dot(Se.direction))<Kn?t.lookAt(e.target):(bt.setFromNormalAndCoplanarPoint(e.object.up,e.target),Se.intersectPlane(bt,e.target))))}else if(e.object.isOrthographicCamera){const ee=e.object.zoom;e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/c)),ee!==e.object.zoom&&(e.object.updateProjectionMatrix(),me=!0)}return c=1,B=!1,me||O.distanceToSquared(e.object.position)>i||8*(1-H.dot(e.object.quaternion))>i||se.distanceToSquared(e.target)>i?(e.dispatchEvent(At),O.copy(e.object.position),H.copy(e.object.quaternion),se.copy(e.target),!0):!1}}(),this.dispose=function(){e.domElement.removeEventListener("contextmenu",ot),e.domElement.removeEventListener("pointerdown",Je),e.domElement.removeEventListener("pointercancel",pe),e.domElement.removeEventListener("wheel",et),e.domElement.removeEventListener("pointermove",Ce),e.domElement.removeEventListener("pointerup",pe),e.domElement.getRootNode().removeEventListener("keydown",tt,{capture:!0}),e._domElementKeyEvents!==null&&(e._domElementKeyEvents.removeEventListener("keydown",Ie),e._domElementKeyEvents=null)};const e=this,s={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let o=s.NONE;const i=1e-6,r=new ct,a=new ct;let c=1;const d=new y,u=new j,h=new j,f=new j,T=new j,b=new j,m=new j,A=new j,E=new j,L=new j,x=new y,k=new j;let B=!1;const _=[],w={};let R=!1;function C(l){return l!==null?2*Math.PI/60*e.autoRotateSpeed*l:2*Math.PI/60/60*e.autoRotateSpeed}function N(l){const g=Math.abs(l*.01);return Math.pow(.95,e.zoomSpeed*g)}function D(l){a.theta-=l}function v(l){a.phi-=l}const S=function(){const l=new y;return function(M,O){l.setFromMatrixColumn(O,0),l.multiplyScalar(-M),d.add(l)}}(),F=function(){const l=new y;return function(M,O){e.screenSpacePanning===!0?l.setFromMatrixColumn(O,1):(l.setFromMatrixColumn(O,0),l.crossVectors(e.object.up,l)),l.multiplyScalar(M),d.add(l)}}(),I=function(){const l=new y;return function(M,O){const H=e.domElement;if(e.object.isPerspectiveCamera){const se=e.object.position;l.copy(se).sub(e.target);let K=l.length();K*=Math.tan(e.object.fov/2*Math.PI/180),S(2*M*K/H.clientHeight,e.object.matrix),F(2*O*K/H.clientHeight,e.object.matrix)}else e.object.isOrthographicCamera?(S(M*(e.object.right-e.object.left)/e.object.zoom/H.clientWidth,e.object.matrix),F(O*(e.object.top-e.object.bottom)/e.object.zoom/H.clientHeight,e.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),e.enablePan=!1)}}();function q(l){e.object.isPerspectiveCamera||e.object.isOrthographicCamera?c/=l:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function fe(l){e.object.isPerspectiveCamera||e.object.isOrthographicCamera?c*=l:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function Q(l,g){if(!e.zoomToCursor)return;B=!0;const M=e.domElement.getBoundingClientRect(),O=l-M.left,H=g-M.top,se=M.width,K=M.height;k.x=O/se*2-1,k.y=-(H/K)*2+1,x.set(k.x,k.y,1).unproject(e.object).sub(e.object.position).normalize()}function G(l){return Math.max(e.minDistance,Math.min(e.maxDistance,l))}function ye(l){u.set(l.clientX,l.clientY)}function X(l){Q(l.clientX,l.clientX),A.set(l.clientX,l.clientY)}function U(l){T.set(l.clientX,l.clientY)}function Ee(l){h.set(l.clientX,l.clientY),f.subVectors(h,u).multiplyScalar(e.rotateSpeed);const g=e.domElement;D(2*Math.PI*f.x/g.clientHeight),v(2*Math.PI*f.y/g.clientHeight),u.copy(h),e.update()}function Ht(l){E.set(l.clientX,l.clientY),L.subVectors(E,A),L.y>0?q(N(L.y)):L.y<0&&fe(N(L.y)),A.copy(E),e.update()}function Gt(l){b.set(l.clientX,l.clientY),m.subVectors(b,T).multiplyScalar(e.panSpeed),I(m.x,m.y),T.copy(b),e.update()}function jt(l){Q(l.clientX,l.clientY),l.deltaY<0?fe(N(l.deltaY)):l.deltaY>0&&q(N(l.deltaY)),e.update()}function Ut(l){let g=!1;switch(l.code){case e.keys.UP:l.ctrlKey||l.metaKey||l.shiftKey?v(2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):I(0,e.keyPanSpeed),g=!0;break;case e.keys.BOTTOM:l.ctrlKey||l.metaKey||l.shiftKey?v(-2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):I(0,-e.keyPanSpeed),g=!0;break;case e.keys.LEFT:l.ctrlKey||l.metaKey||l.shiftKey?D(2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):I(e.keyPanSpeed,0),g=!0;break;case e.keys.RIGHT:l.ctrlKey||l.metaKey||l.shiftKey?D(-2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):I(-e.keyPanSpeed,0),g=!0;break}g&&(l.preventDefault(),e.update())}function We(l){if(_.length===1)u.set(l.pageX,l.pageY);else{const g=ue(l),M=.5*(l.pageX+g.x),O=.5*(l.pageY+g.y);u.set(M,O)}}function Ye(l){if(_.length===1)T.set(l.pageX,l.pageY);else{const g=ue(l),M=.5*(l.pageX+g.x),O=.5*(l.pageY+g.y);T.set(M,O)}}function qe(l){const g=ue(l),M=l.pageX-g.x,O=l.pageY-g.y,H=Math.sqrt(M*M+O*O);A.set(0,H)}function Kt(l){e.enableZoom&&qe(l),e.enablePan&&Ye(l)}function zt(l){e.enableZoom&&qe(l),e.enableRotate&&We(l)}function $e(l){if(_.length==1)h.set(l.pageX,l.pageY);else{const M=ue(l),O=.5*(l.pageX+M.x),H=.5*(l.pageY+M.y);h.set(O,H)}f.subVectors(h,u).multiplyScalar(e.rotateSpeed);const g=e.domElement;D(2*Math.PI*f.x/g.clientHeight),v(2*Math.PI*f.y/g.clientHeight),u.copy(h)}function Qe(l){if(_.length===1)b.set(l.pageX,l.pageY);else{const g=ue(l),M=.5*(l.pageX+g.x),O=.5*(l.pageY+g.y);b.set(M,O)}m.subVectors(b,T).multiplyScalar(e.panSpeed),I(m.x,m.y),T.copy(b)}function Ze(l){const g=ue(l),M=l.pageX-g.x,O=l.pageY-g.y,H=Math.sqrt(M*M+O*O);E.set(0,H),L.set(0,Math.pow(E.y/A.y,e.zoomSpeed)),q(L.y),A.copy(E);const se=(l.pageX+g.x)*.5,K=(l.pageY+g.y)*.5;Q(se,K)}function Vt(l){e.enableZoom&&Ze(l),e.enablePan&&Qe(l)}function Xt(l){e.enableZoom&&Ze(l),e.enableRotate&&$e(l)}function Je(l){e.enabled!==!1&&(_.length===0&&(e.domElement.setPointerCapture(l.pointerId),e.domElement.addEventListener("pointermove",Ce),e.domElement.addEventListener("pointerup",pe)),!Jt(l)&&(Qt(l),l.pointerType==="touch"?st(l):Wt(l)))}function Ce(l){e.enabled!==!1&&(l.pointerType==="touch"?$t(l):Yt(l))}function pe(l){switch(Zt(l),_.length){case 0:e.domElement.releasePointerCapture(l.pointerId),e.domElement.removeEventListener("pointermove",Ce),e.domElement.removeEventListener("pointerup",pe),e.dispatchEvent(wt),o=s.NONE;break;case 1:const g=_[0],M=w[g];st({pointerId:g,pageX:M.x,pageY:M.y});break}}function Wt(l){let g;switch(l.button){case 0:g=e.mouseButtons.LEFT;break;case 1:g=e.mouseButtons.MIDDLE;break;case 2:g=e.mouseButtons.RIGHT;break;default:g=-1}switch(g){case W.DOLLY:if(e.enableZoom===!1)return;X(l),o=s.DOLLY;break;case W.ROTATE:if(l.ctrlKey||l.metaKey||l.shiftKey){if(e.enablePan===!1)return;U(l),o=s.PAN}else{if(e.enableRotate===!1)return;ye(l),o=s.ROTATE}break;case W.PAN:if(l.ctrlKey||l.metaKey||l.shiftKey){if(e.enableRotate===!1)return;ye(l),o=s.ROTATE}else{if(e.enablePan===!1)return;U(l),o=s.PAN}break;default:o=s.NONE}o!==s.NONE&&e.dispatchEvent(Oe)}function Yt(l){switch(o){case s.ROTATE:if(e.enableRotate===!1)return;Ee(l);break;case s.DOLLY:if(e.enableZoom===!1)return;Ht(l);break;case s.PAN:if(e.enablePan===!1)return;Gt(l);break}}function et(l){e.enabled===!1||e.enableZoom===!1||o!==s.NONE||(l.preventDefault(),e.dispatchEvent(Oe),jt(qt(l)),e.dispatchEvent(wt))}function qt(l){const g=l.deltaMode,M={clientX:l.clientX,clientY:l.clientY,deltaY:l.deltaY};switch(g){case 1:M.deltaY*=16;break;case 2:M.deltaY*=100;break}return l.ctrlKey&&!R&&(M.deltaY*=10),M}function tt(l){l.key==="Control"&&(R=!0,e.domElement.getRootNode().addEventListener("keyup",nt,{passive:!0,capture:!0}))}function nt(l){l.key==="Control"&&(R=!1,e.domElement.getRootNode().removeEventListener("keyup",nt,{passive:!0,capture:!0}))}function Ie(l){e.enabled===!1||e.enablePan===!1||Ut(l)}function st(l){switch(it(l),_.length){case 1:switch(e.touches.ONE){case de.ROTATE:if(e.enableRotate===!1)return;We(l),o=s.TOUCH_ROTATE;break;case de.PAN:if(e.enablePan===!1)return;Ye(l),o=s.TOUCH_PAN;break;default:o=s.NONE}break;case 2:switch(e.touches.TWO){case de.DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;Kt(l),o=s.TOUCH_DOLLY_PAN;break;case de.DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;zt(l),o=s.TOUCH_DOLLY_ROTATE;break;default:o=s.NONE}break;default:o=s.NONE}o!==s.NONE&&e.dispatchEvent(Oe)}function $t(l){switch(it(l),o){case s.TOUCH_ROTATE:if(e.enableRotate===!1)return;$e(l),e.update();break;case s.TOUCH_PAN:if(e.enablePan===!1)return;Qe(l),e.update();break;case s.TOUCH_DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;Vt(l),e.update();break;case s.TOUCH_DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;Xt(l),e.update();break;default:o=s.NONE}}function ot(l){e.enabled!==!1&&l.preventDefault()}function Qt(l){_.push(l.pointerId)}function Zt(l){delete w[l.pointerId];for(let g=0;g<_.length;g++)if(_[g]==l.pointerId){_.splice(g,1);return}}function Jt(l){for(let g=0;g<_.length;g++)if(_[g]==l.pointerId)return!0;return!1}function it(l){let g=w[l.pointerId];g===void 0&&(g=new j,w[l.pointerId]=g),g.set(l.pageX,l.pageY)}function ue(l){const g=l.pointerId===_[0]?_[1]:_[0];return w[g]}e.domElement.addEventListener("contextmenu",ot),e.domElement.addEventListener("pointerdown",Je),e.domElement.addEventListener("pointercancel",pe),e.domElement.addEventListener("wheel",et,{passive:!1}),e.domElement.getRootNode().addEventListener("keydown",tt,{passive:!0,capture:!0}),this.update()}}function yt(p,t){if(t===on)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),p;if(t===He||t===Mt){let n=p.getIndex();if(n===null){const i=[],r=p.getAttribute("position");if(r!==void 0){for(let a=0;a<r.count;a++)i.push(a);p.setIndex(i),n=p.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),p}const e=n.count-2,s=[];if(t===He)for(let i=1;i<=e;i++)s.push(n.getX(0)),s.push(n.getX(i)),s.push(n.getX(i+1));else for(let i=0;i<e;i++)i%2===0?(s.push(n.getX(i)),s.push(n.getX(i+1)),s.push(n.getX(i+2))):(s.push(n.getX(i+2)),s.push(n.getX(i+1)),s.push(n.getX(i)));s.length/3!==e&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const o=p.clone();return o.setIndex(s),o.clearGroups(),o}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),p}class Vn extends Pt{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(n){return new $n(n)}),this.register(function(n){return new is(n)}),this.register(function(n){return new rs(n)}),this.register(function(n){return new as(n)}),this.register(function(n){return new Zn(n)}),this.register(function(n){return new Jn(n)}),this.register(function(n){return new es(n)}),this.register(function(n){return new ts(n)}),this.register(function(n){return new qn(n)}),this.register(function(n){return new ns(n)}),this.register(function(n){return new Qn(n)}),this.register(function(n){return new os(n)}),this.register(function(n){return new ss(n)}),this.register(function(n){return new Wn(n)}),this.register(function(n){return new cs(n)}),this.register(function(n){return new ls(n)})}load(t,n,e,s){const o=this;let i;if(this.resourcePath!=="")i=this.resourcePath;else if(this.path!==""){const c=Ae.extractUrlBase(t);i=Ae.resolveURL(c,this.path)}else i=Ae.extractUrlBase(t);this.manager.itemStart(t);const r=function(c){s?s(c):console.error(c),o.manager.itemError(t),o.manager.itemEnd(t)},a=new Me(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(c){try{o.parse(c,i,function(d){n(d),o.manager.itemEnd(t)},r)}catch(d){r(d)}},e,r)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return this.pluginCallbacks.indexOf(t)===-1&&this.pluginCallbacks.push(t),this}unregister(t){return this.pluginCallbacks.indexOf(t)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,n,e,s){let o;const i={},r={},a=new TextDecoder;if(typeof t=="string")o=JSON.parse(t);else if(t instanceof ArrayBuffer)if(a.decode(new Uint8Array(t,0,4))===vt){try{i[P.KHR_BINARY_GLTF]=new us(t)}catch(u){s&&s(u);return}o=JSON.parse(i[P.KHR_BINARY_GLTF].content)}else o=JSON.parse(a.decode(t));else o=t;if(o.asset===void 0||o.asset.version[0]<2){s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new Rs(o,{path:n||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let d=0;d<this.pluginCallbacks.length;d++){const u=this.pluginCallbacks[d](c);u.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),r[u.name]=u,i[u.name]=!0}if(o.extensionsUsed)for(let d=0;d<o.extensionsUsed.length;++d){const u=o.extensionsUsed[d],h=o.extensionsRequired||[];switch(u){case P.KHR_MATERIALS_UNLIT:i[u]=new Yn;break;case P.KHR_DRACO_MESH_COMPRESSION:i[u]=new ds(o,this.dracoLoader);break;case P.KHR_TEXTURE_TRANSFORM:i[u]=new hs;break;case P.KHR_MESH_QUANTIZATION:i[u]=new fs;break;default:h.indexOf(u)>=0&&r[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}c.setExtensions(i),c.setPlugins(r),c.parse(e,s)}parseAsync(t,n){const e=this;return new Promise(function(s,o){e.parse(t,n,s,o)})}}function Xn(){let p={};return{get:function(t){return p[t]},add:function(t,n){p[t]=n},remove:function(t){delete p[t]},removeAll:function(){p={}}}}const P={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Wn{constructor(t){this.parser=t,this.name=P.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,n=this.parser.json.nodes||[];for(let e=0,s=n.length;e<s;e++){const o=n[e];o.extensions&&o.extensions[this.name]&&o.extensions[this.name].light!==void 0&&t._addNodeRef(this.cache,o.extensions[this.name].light)}}_loadLight(t){const n=this.parser,e="light:"+t;let s=n.cache.get(e);if(s)return s;const o=n.json,a=((o.extensions&&o.extensions[this.name]||{}).lights||[])[t];let c;const d=new te(16777215);a.color!==void 0&&d.setRGB(a.color[0],a.color[1],a.color[2],Y);const u=a.range!==void 0?a.range:0;switch(a.type){case"directional":c=new Ct(d),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new an(d),c.distance=u;break;case"spot":c=new rn(d),c.distance=u,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,c.angle=a.spot.outerConeAngle,c.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return c.position.set(0,0,0),c.decay=2,ie(c,a),a.intensity!==void 0&&(c.intensity=a.intensity),c.name=n.createUniqueName(a.name||"light_"+t),s=Promise.resolve(c),n.cache.add(e,s),s}getDependency(t,n){if(t==="light")return this._loadLight(n)}createNodeAttachment(t){const n=this,e=this.parser,o=e.json.nodes[t],r=(o.extensions&&o.extensions[this.name]||{}).light;return r===void 0?null:this._loadLight(r).then(function(a){return e._getNodeRef(n.cache,r,a)})}}class Yn{constructor(){this.name=P.KHR_MATERIALS_UNLIT}getMaterialType(){return ce}extendParams(t,n,e){const s=[];t.color=new te(1,1,1),t.opacity=1;const o=n.pbrMetallicRoughness;if(o){if(Array.isArray(o.baseColorFactor)){const i=o.baseColorFactor;t.color.setRGB(i[0],i[1],i[2],Y),t.opacity=i[3]}o.baseColorTexture!==void 0&&s.push(e.assignTexture(t,"map",o.baseColorTexture,$))}return Promise.all(s)}}class qn{constructor(t){this.parser=t,this.name=P.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(t,n){const s=this.parser.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=s.extensions[this.name].emissiveStrength;return o!==void 0&&(n.emissiveIntensity=o),Promise.resolve()}}class $n{constructor(t){this.parser=t,this.name=P.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:ne}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[],i=s.extensions[this.name];if(i.clearcoatFactor!==void 0&&(n.clearcoat=i.clearcoatFactor),i.clearcoatTexture!==void 0&&o.push(e.assignTexture(n,"clearcoatMap",i.clearcoatTexture)),i.clearcoatRoughnessFactor!==void 0&&(n.clearcoatRoughness=i.clearcoatRoughnessFactor),i.clearcoatRoughnessTexture!==void 0&&o.push(e.assignTexture(n,"clearcoatRoughnessMap",i.clearcoatRoughnessTexture)),i.clearcoatNormalTexture!==void 0&&(o.push(e.assignTexture(n,"clearcoatNormalMap",i.clearcoatNormalTexture)),i.clearcoatNormalTexture.scale!==void 0)){const r=i.clearcoatNormalTexture.scale;n.clearcoatNormalScale=new j(r,r)}return Promise.all(o)}}class Qn{constructor(t){this.parser=t,this.name=P.KHR_MATERIALS_IRIDESCENCE}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:ne}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[],i=s.extensions[this.name];return i.iridescenceFactor!==void 0&&(n.iridescence=i.iridescenceFactor),i.iridescenceTexture!==void 0&&o.push(e.assignTexture(n,"iridescenceMap",i.iridescenceTexture)),i.iridescenceIor!==void 0&&(n.iridescenceIOR=i.iridescenceIor),n.iridescenceThicknessRange===void 0&&(n.iridescenceThicknessRange=[100,400]),i.iridescenceThicknessMinimum!==void 0&&(n.iridescenceThicknessRange[0]=i.iridescenceThicknessMinimum),i.iridescenceThicknessMaximum!==void 0&&(n.iridescenceThicknessRange[1]=i.iridescenceThicknessMaximum),i.iridescenceThicknessTexture!==void 0&&o.push(e.assignTexture(n,"iridescenceThicknessMap",i.iridescenceThicknessTexture)),Promise.all(o)}}class Zn{constructor(t){this.parser=t,this.name=P.KHR_MATERIALS_SHEEN}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:ne}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[];n.sheenColor=new te(0,0,0),n.sheenRoughness=0,n.sheen=1;const i=s.extensions[this.name];if(i.sheenColorFactor!==void 0){const r=i.sheenColorFactor;n.sheenColor.setRGB(r[0],r[1],r[2],Y)}return i.sheenRoughnessFactor!==void 0&&(n.sheenRoughness=i.sheenRoughnessFactor),i.sheenColorTexture!==void 0&&o.push(e.assignTexture(n,"sheenColorMap",i.sheenColorTexture,$)),i.sheenRoughnessTexture!==void 0&&o.push(e.assignTexture(n,"sheenRoughnessMap",i.sheenRoughnessTexture)),Promise.all(o)}}class Jn{constructor(t){this.parser=t,this.name=P.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:ne}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[],i=s.extensions[this.name];return i.transmissionFactor!==void 0&&(n.transmission=i.transmissionFactor),i.transmissionTexture!==void 0&&o.push(e.assignTexture(n,"transmissionMap",i.transmissionTexture)),Promise.all(o)}}class es{constructor(t){this.parser=t,this.name=P.KHR_MATERIALS_VOLUME}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:ne}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[],i=s.extensions[this.name];n.thickness=i.thicknessFactor!==void 0?i.thicknessFactor:0,i.thicknessTexture!==void 0&&o.push(e.assignTexture(n,"thicknessMap",i.thicknessTexture)),n.attenuationDistance=i.attenuationDistance||1/0;const r=i.attenuationColor||[1,1,1];return n.attenuationColor=new te().setRGB(r[0],r[1],r[2],Y),Promise.all(o)}}class ts{constructor(t){this.parser=t,this.name=P.KHR_MATERIALS_IOR}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:ne}extendMaterialParams(t,n){const s=this.parser.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=s.extensions[this.name];return n.ior=o.ior!==void 0?o.ior:1.5,Promise.resolve()}}class ns{constructor(t){this.parser=t,this.name=P.KHR_MATERIALS_SPECULAR}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:ne}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[],i=s.extensions[this.name];n.specularIntensity=i.specularFactor!==void 0?i.specularFactor:1,i.specularTexture!==void 0&&o.push(e.assignTexture(n,"specularIntensityMap",i.specularTexture));const r=i.specularColorFactor||[1,1,1];return n.specularColor=new te().setRGB(r[0],r[1],r[2],Y),i.specularColorTexture!==void 0&&o.push(e.assignTexture(n,"specularColorMap",i.specularColorTexture,$)),Promise.all(o)}}class ss{constructor(t){this.parser=t,this.name=P.EXT_MATERIALS_BUMP}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:ne}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[],i=s.extensions[this.name];return n.bumpScale=i.bumpFactor!==void 0?i.bumpFactor:1,i.bumpTexture!==void 0&&o.push(e.assignTexture(n,"bumpMap",i.bumpTexture)),Promise.all(o)}}class os{constructor(t){this.parser=t,this.name=P.KHR_MATERIALS_ANISOTROPY}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:ne}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[],i=s.extensions[this.name];return i.anisotropyStrength!==void 0&&(n.anisotropy=i.anisotropyStrength),i.anisotropyRotation!==void 0&&(n.anisotropyRotation=i.anisotropyRotation),i.anisotropyTexture!==void 0&&o.push(e.assignTexture(n,"anisotropyMap",i.anisotropyTexture)),Promise.all(o)}}class is{constructor(t){this.parser=t,this.name=P.KHR_TEXTURE_BASISU}loadTexture(t){const n=this.parser,e=n.json,s=e.textures[t];if(!s.extensions||!s.extensions[this.name])return null;const o=s.extensions[this.name],i=n.options.ktx2Loader;if(!i){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return n.loadTextureImage(t,o.source,i)}}class rs{constructor(t){this.parser=t,this.name=P.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const n=this.name,e=this.parser,s=e.json,o=s.textures[t];if(!o.extensions||!o.extensions[n])return null;const i=o.extensions[n],r=s.images[i.source];let a=e.textureLoader;if(r.uri){const c=e.options.manager.getHandler(r.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return e.loadTextureImage(t,i.source,a);if(s.extensionsRequired&&s.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return e.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const n=new Image;n.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",n.onload=n.onerror=function(){t(n.height===1)}})),this.isSupported}}class as{constructor(t){this.parser=t,this.name=P.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(t){const n=this.name,e=this.parser,s=e.json,o=s.textures[t];if(!o.extensions||!o.extensions[n])return null;const i=o.extensions[n],r=s.images[i.source];let a=e.textureLoader;if(r.uri){const c=e.options.manager.getHandler(r.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return e.loadTextureImage(t,i.source,a);if(s.extensionsRequired&&s.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return e.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const n=new Image;n.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",n.onload=n.onerror=function(){t(n.height===1)}})),this.isSupported}}class cs{constructor(t){this.name=P.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const n=this.parser.json,e=n.bufferViews[t];if(e.extensions&&e.extensions[this.name]){const s=e.extensions[this.name],o=this.parser.getDependency("buffer",s.buffer),i=this.parser.options.meshoptDecoder;if(!i||!i.supported){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return o.then(function(r){const a=s.byteOffset||0,c=s.byteLength||0,d=s.count,u=s.byteStride,h=new Uint8Array(r,a,c);return i.decodeGltfBufferAsync?i.decodeGltfBufferAsync(d,u,h,s.mode,s.filter).then(function(f){return f.buffer}):i.ready.then(function(){const f=new ArrayBuffer(d*u);return i.decodeGltfBuffer(new Uint8Array(f),d,u,h,s.mode,s.filter),f})})}else return null}}class ls{constructor(t){this.name=P.EXT_MESH_GPU_INSTANCING,this.parser=t}createNodeMesh(t){const n=this.parser.json,e=n.nodes[t];if(!e.extensions||!e.extensions[this.name]||e.mesh===void 0)return null;const s=n.meshes[e.mesh];for(const c of s.primitives)if(c.mode!==z.TRIANGLES&&c.mode!==z.TRIANGLE_STRIP&&c.mode!==z.TRIANGLE_FAN&&c.mode!==void 0)return null;const i=e.extensions[this.name].attributes,r=[],a={};for(const c in i)r.push(this.parser.getDependency("accessor",i[c]).then(d=>(a[c]=d,a[c])));return r.length<1?null:(r.push(this.parser.createNodeMesh(t)),Promise.all(r).then(c=>{const d=c.pop(),u=d.isGroup?d.children:[d],h=c[0].count,f=[];for(const T of u){const b=new Pe,m=new y,A=new V,E=new y(1,1,1),L=new cn(T.geometry,T.material,h);for(let x=0;x<h;x++)a.TRANSLATION&&m.fromBufferAttribute(a.TRANSLATION,x),a.ROTATION&&A.fromBufferAttribute(a.ROTATION,x),a.SCALE&&E.fromBufferAttribute(a.SCALE,x),L.setMatrixAt(x,b.compose(m,A,E));for(const x in a)if(x==="_COLOR_0"){const k=a[x];L.instanceColor=new ln(k.array,k.itemSize,k.normalized)}else x!=="TRANSLATION"&&x!=="ROTATION"&&x!=="SCALE"&&T.geometry.setAttribute(x,a[x]);Ve.prototype.copy.call(L,T),this.parser.assignFinalMaterial(L),f.push(L)}return d.isGroup?(d.clear(),d.add(...f),d):f[0]}))}}const vt="glTF",Te=12,Et={JSON:1313821514,BIN:5130562};class us{constructor(t){this.name=P.KHR_BINARY_GLTF,this.content=null,this.body=null;const n=new DataView(t,0,Te),e=new TextDecoder;if(this.header={magic:e.decode(new Uint8Array(t.slice(0,4))),version:n.getUint32(4,!0),length:n.getUint32(8,!0)},this.header.magic!==vt)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const s=this.header.length-Te,o=new DataView(t,Te);let i=0;for(;i<s;){const r=o.getUint32(i,!0);i+=4;const a=o.getUint32(i,!0);if(i+=4,a===Et.JSON){const c=new Uint8Array(t,Te+i,r);this.content=e.decode(c)}else if(a===Et.BIN){const c=Te+i;this.body=t.slice(c,c+r)}i+=r}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class ds{constructor(t,n){if(!n)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=P.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=n,this.dracoLoader.preload()}decodePrimitive(t,n){const e=this.json,s=this.dracoLoader,o=t.extensions[this.name].bufferView,i=t.extensions[this.name].attributes,r={},a={},c={};for(const d in i){const u=Ke[d]||d.toLowerCase();r[u]=i[d]}for(const d in t.attributes){const u=Ke[d]||d.toLowerCase();if(i[d]!==void 0){const h=e.accessors[t.attributes[d]],f=he[h.componentType];c[u]=f.name,a[u]=h.normalized===!0}}return n.getDependency("bufferView",o).then(function(d){return new Promise(function(u,h){s.decodeDracoFile(d,function(f){for(const T in f.attributes){const b=f.attributes[T],m=a[T];m!==void 0&&(b.normalized=m)}u(f)},r,c,Y,h)})})}}class hs{constructor(){this.name=P.KHR_TEXTURE_TRANSFORM}extendTexture(t,n){return(n.texCoord===void 0||n.texCoord===t.channel)&&n.offset===void 0&&n.rotation===void 0&&n.scale===void 0||(t=t.clone(),n.texCoord!==void 0&&(t.channel=n.texCoord),n.offset!==void 0&&t.offset.fromArray(n.offset),n.rotation!==void 0&&(t.rotation=n.rotation),n.scale!==void 0&&t.repeat.fromArray(n.scale),t.needsUpdate=!0),t}}class fs{constructor(){this.name=P.KHR_MESH_QUANTIZATION}}class Ft extends kn{constructor(t,n,e,s){super(t,n,e,s)}copySampleValue_(t){const n=this.resultBuffer,e=this.sampleValues,s=this.valueSize,o=t*s*3+s;for(let i=0;i!==s;i++)n[i]=e[o+i];return n}interpolate_(t,n,e,s){const o=this.resultBuffer,i=this.sampleValues,r=this.valueSize,a=r*2,c=r*3,d=s-n,u=(e-n)/d,h=u*u,f=h*u,T=t*c,b=T-c,m=-2*f+3*h,A=f-h,E=1-m,L=A-h+u;for(let x=0;x!==r;x++){const k=i[b+x+r],B=i[b+x+a]*d,_=i[T+x+r],w=i[T+x]*d;o[x]=E*k+L*B+m*_+A*w}return o}}const ps=new V;class ms extends Ft{interpolate_(t,n,e,s){const o=super.interpolate_(t,n,e,s);return ps.fromArray(o).normalize().toArray(o),o}}const z={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},he={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Rt={9728:mn,9729:le,9984:pn,9985:fn,9986:hn,9987:be},xt={33071:Tn,33648:gn,10497:Ge},De={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Ke={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},oe={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},gs={CUBICSPLINE:void 0,LINEAR:Dt,STEP:Pn},ve={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Ts(p){return p.DefaultMaterial===void 0&&(p.DefaultMaterial=new ae({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:In})),p.DefaultMaterial}function re(p,t,n){for(const e in n.extensions)p[e]===void 0&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[e]=n.extensions[e])}function ie(p,t){t.extras!==void 0&&(typeof t.extras=="object"?Object.assign(p.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function As(p,t,n){let e=!1,s=!1,o=!1;for(let c=0,d=t.length;c<d;c++){const u=t[c];if(u.POSITION!==void 0&&(e=!0),u.NORMAL!==void 0&&(s=!0),u.COLOR_0!==void 0&&(o=!0),e&&s&&o)break}if(!e&&!s&&!o)return Promise.resolve(p);const i=[],r=[],a=[];for(let c=0,d=t.length;c<d;c++){const u=t[c];if(e){const h=u.POSITION!==void 0?n.getDependency("accessor",u.POSITION):p.attributes.position;i.push(h)}if(s){const h=u.NORMAL!==void 0?n.getDependency("accessor",u.NORMAL):p.attributes.normal;r.push(h)}if(o){const h=u.COLOR_0!==void 0?n.getDependency("accessor",u.COLOR_0):p.attributes.color;a.push(h)}}return Promise.all([Promise.all(i),Promise.all(r),Promise.all(a)]).then(function(c){const d=c[0],u=c[1],h=c[2];return e&&(p.morphAttributes.position=d),s&&(p.morphAttributes.normal=u),o&&(p.morphAttributes.color=h),p.morphTargetsRelative=!0,p})}function ws(p,t){if(p.updateMorphTargets(),t.weights!==void 0)for(let n=0,e=t.weights.length;n<e;n++)p.morphTargetInfluences[n]=t.weights[n];if(t.extras&&Array.isArray(t.extras.targetNames)){const n=t.extras.targetNames;if(p.morphTargetInfluences.length===n.length){p.morphTargetDictionary={};for(let e=0,s=n.length;e<s;e++)p.morphTargetDictionary[n[e]]=e}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function bs(p){let t;const n=p.extensions&&p.extensions[P.KHR_DRACO_MESH_COMPRESSION];if(n?t="draco:"+n.bufferView+":"+n.indices+":"+Fe(n.attributes):t=p.indices+":"+Fe(p.attributes)+":"+p.mode,p.targets!==void 0)for(let e=0,s=p.targets.length;e<s;e++)t+=":"+Fe(p.targets[e]);return t}function Fe(p){let t="";const n=Object.keys(p).sort();for(let e=0,s=n.length;e<s;e++)t+=n[e]+":"+p[n[e]]+";";return t}function ze(p){switch(p){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function ys(p){return p.search(/\.jpe?g($|\?)/i)>0||p.search(/^data\:image\/jpeg/)===0?"image/jpeg":p.search(/\.webp($|\?)/i)>0||p.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Es=new Pe;class Rs{constructor(t={},n={}){this.json=t,this.extensions={},this.plugins={},this.options=n,this.cache=new Xn,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let e=!1,s=!1,o=-1;typeof navigator<"u"&&(e=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,s=navigator.userAgent.indexOf("Firefox")>-1,o=s?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||e||s&&o<98?this.textureLoader=new It(this.options.manager):this.textureLoader=new un(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Me(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,n){const e=this,s=this.json,o=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(i){return i._markDefs&&i._markDefs()}),Promise.all(this._invokeAll(function(i){return i.beforeRoot&&i.beforeRoot()})).then(function(){return Promise.all([e.getDependencies("scene"),e.getDependencies("animation"),e.getDependencies("camera")])}).then(function(i){const r={scene:i[0][s.scene||0],scenes:i[0],animations:i[1],cameras:i[2],asset:s.asset,parser:e,userData:{}};return re(o,r,s),ie(r,s),Promise.all(e._invokeAll(function(a){return a.afterRoot&&a.afterRoot(r)})).then(function(){t(r)})}).catch(n)}_markDefs(){const t=this.json.nodes||[],n=this.json.skins||[],e=this.json.meshes||[];for(let s=0,o=n.length;s<o;s++){const i=n[s].joints;for(let r=0,a=i.length;r<a;r++)t[i[r]].isBone=!0}for(let s=0,o=t.length;s<o;s++){const i=t[s];i.mesh!==void 0&&(this._addNodeRef(this.meshCache,i.mesh),i.skin!==void 0&&(e[i.mesh].isSkinnedMesh=!0)),i.camera!==void 0&&this._addNodeRef(this.cameraCache,i.camera)}}_addNodeRef(t,n){n!==void 0&&(t.refs[n]===void 0&&(t.refs[n]=t.uses[n]=0),t.refs[n]++)}_getNodeRef(t,n,e){if(t.refs[n]<=1)return e;const s=e.clone(),o=(i,r)=>{const a=this.associations.get(i);a!=null&&this.associations.set(r,a);for(const[c,d]of i.children.entries())o(d,r.children[c])};return o(e,s),s.name+="_instance_"+t.uses[n]++,s}_invokeOne(t){const n=Object.values(this.plugins);n.push(this);for(let e=0;e<n.length;e++){const s=t(n[e]);if(s)return s}return null}_invokeAll(t){const n=Object.values(this.plugins);n.unshift(this);const e=[];for(let s=0;s<n.length;s++){const o=t(n[s]);o&&e.push(o)}return e}getDependency(t,n){const e=t+":"+n;let s=this.cache.get(e);if(!s){switch(t){case"scene":s=this.loadScene(n);break;case"node":s=this._invokeOne(function(o){return o.loadNode&&o.loadNode(n)});break;case"mesh":s=this._invokeOne(function(o){return o.loadMesh&&o.loadMesh(n)});break;case"accessor":s=this.loadAccessor(n);break;case"bufferView":s=this._invokeOne(function(o){return o.loadBufferView&&o.loadBufferView(n)});break;case"buffer":s=this.loadBuffer(n);break;case"material":s=this._invokeOne(function(o){return o.loadMaterial&&o.loadMaterial(n)});break;case"texture":s=this._invokeOne(function(o){return o.loadTexture&&o.loadTexture(n)});break;case"skin":s=this.loadSkin(n);break;case"animation":s=this._invokeOne(function(o){return o.loadAnimation&&o.loadAnimation(n)});break;case"camera":s=this.loadCamera(n);break;default:if(s=this._invokeOne(function(o){return o!=this&&o.getDependency&&o.getDependency(t,n)}),!s)throw new Error("Unknown type: "+t);break}this.cache.add(e,s)}return s}getDependencies(t){let n=this.cache.get(t);if(!n){const e=this,s=this.json[t+(t==="mesh"?"es":"s")]||[];n=Promise.all(s.map(function(o,i){return e.getDependency(t,i)})),this.cache.add(t,n)}return n}loadBuffer(t){const n=this.json.buffers[t],e=this.fileLoader;if(n.type&&n.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+n.type+" buffer type is not supported.");if(n.uri===void 0&&t===0)return Promise.resolve(this.extensions[P.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(o,i){e.load(Ae.resolveURL(n.uri,s.path),o,void 0,function(){i(new Error('THREE.GLTFLoader: Failed to load buffer "'+n.uri+'".'))})})}loadBufferView(t){const n=this.json.bufferViews[t];return this.getDependency("buffer",n.buffer).then(function(e){const s=n.byteLength||0,o=n.byteOffset||0;return e.slice(o,o+s)})}loadAccessor(t){const n=this,e=this.json,s=this.json.accessors[t];if(s.bufferView===void 0&&s.sparse===void 0){const i=De[s.type],r=he[s.componentType],a=s.normalized===!0,c=new r(s.count*i);return Promise.resolve(new we(c,i,a))}const o=[];return s.bufferView!==void 0?o.push(this.getDependency("bufferView",s.bufferView)):o.push(null),s.sparse!==void 0&&(o.push(this.getDependency("bufferView",s.sparse.indices.bufferView)),o.push(this.getDependency("bufferView",s.sparse.values.bufferView))),Promise.all(o).then(function(i){const r=i[0],a=De[s.type],c=he[s.componentType],d=c.BYTES_PER_ELEMENT,u=d*a,h=s.byteOffset||0,f=s.bufferView!==void 0?e.bufferViews[s.bufferView].byteStride:void 0,T=s.normalized===!0;let b,m;if(f&&f!==u){const A=Math.floor(h/f),E="InterleavedBuffer:"+s.bufferView+":"+s.componentType+":"+A+":"+s.count;let L=n.cache.get(E);L||(b=new c(r,A*f,s.count*f/d),L=new dn(b,f/d),n.cache.add(E,L)),m=new Cn(L,a,h%f/d,T)}else r===null?b=new c(s.count*a):b=new c(r,h,s.count*a),m=new we(b,a,T);if(s.sparse!==void 0){const A=De.SCALAR,E=he[s.sparse.indices.componentType],L=s.sparse.indices.byteOffset||0,x=s.sparse.values.byteOffset||0,k=new E(i[1],L,s.sparse.count*A),B=new c(i[2],x,s.sparse.count*a);r!==null&&(m=new we(m.array.slice(),m.itemSize,m.normalized));for(let _=0,w=k.length;_<w;_++){const R=k[_];if(m.setX(R,B[_*a]),a>=2&&m.setY(R,B[_*a+1]),a>=3&&m.setZ(R,B[_*a+2]),a>=4&&m.setW(R,B[_*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return m})}loadTexture(t){const n=this.json,e=this.options,o=n.textures[t].source,i=n.images[o];let r=this.textureLoader;if(i.uri){const a=e.manager.getHandler(i.uri);a!==null&&(r=a)}return this.loadTextureImage(t,o,r)}loadTextureImage(t,n,e){const s=this,o=this.json,i=o.textures[t],r=o.images[n],a=(r.uri||r.bufferView)+":"+i.sampler;if(this.textureCache[a])return this.textureCache[a];const c=this.loadImageSource(n,e).then(function(d){d.flipY=!1,d.name=i.name||r.name||"",d.name===""&&typeof r.uri=="string"&&r.uri.startsWith("data:image/")===!1&&(d.name=r.uri);const h=(o.samplers||{})[i.sampler]||{};return d.magFilter=Rt[h.magFilter]||le,d.minFilter=Rt[h.minFilter]||be,d.wrapS=xt[h.wrapS]||Ge,d.wrapT=xt[h.wrapT]||Ge,s.associations.set(d,{textures:t}),d}).catch(function(){return null});return this.textureCache[a]=c,c}loadImageSource(t,n){const e=this,s=this.json,o=this.options;if(this.sourceCache[t]!==void 0)return this.sourceCache[t].then(u=>u.clone());const i=s.images[t],r=self.URL||self.webkitURL;let a=i.uri||"",c=!1;if(i.bufferView!==void 0)a=e.getDependency("bufferView",i.bufferView).then(function(u){c=!0;const h=new Blob([u],{type:i.mimeType});return a=r.createObjectURL(h),a});else if(i.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const d=Promise.resolve(a).then(function(u){return new Promise(function(h,f){let T=h;n.isImageBitmapLoader===!0&&(T=function(b){const m=new lt(b);m.needsUpdate=!0,h(m)}),n.load(Ae.resolveURL(u,o.path),T,void 0,f)})}).then(function(u){return c===!0&&r.revokeObjectURL(a),u.userData.mimeType=i.mimeType||ys(i.uri),u}).catch(function(u){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),u});return this.sourceCache[t]=d,d}assignTexture(t,n,e,s){const o=this;return this.getDependency("texture",e.index).then(function(i){if(!i)return null;if(e.texCoord!==void 0&&e.texCoord>0&&(i=i.clone(),i.channel=e.texCoord),o.extensions[P.KHR_TEXTURE_TRANSFORM]){const r=e.extensions!==void 0?e.extensions[P.KHR_TEXTURE_TRANSFORM]:void 0;if(r){const a=o.associations.get(i);i=o.extensions[P.KHR_TEXTURE_TRANSFORM].extendTexture(i,r),o.associations.set(i,a)}}return s!==void 0&&(i.colorSpace=s),t[n]=i,i})}assignFinalMaterial(t){const n=t.geometry;let e=t.material;const s=n.attributes.tangent===void 0,o=n.attributes.color!==void 0,i=n.attributes.normal===void 0;if(t.isPoints){const r="PointsMaterial:"+e.uuid;let a=this.cache.get(r);a||(a=new An,ke.prototype.copy.call(a,e),a.color.copy(e.color),a.map=e.map,a.sizeAttenuation=!1,this.cache.add(r,a)),e=a}else if(t.isLine){const r="LineBasicMaterial:"+e.uuid;let a=this.cache.get(r);a||(a=new kt,ke.prototype.copy.call(a,e),a.color.copy(e.color),a.map=e.map,this.cache.add(r,a)),e=a}if(s||o||i){let r="ClonedMaterial:"+e.uuid+":";s&&(r+="derivative-tangents:"),o&&(r+="vertex-colors:"),i&&(r+="flat-shading:");let a=this.cache.get(r);a||(a=e.clone(),o&&(a.vertexColors=!0),i&&(a.flatShading=!0),s&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(r,a),this.associations.set(a,this.associations.get(e))),e=a}t.material=e}getMaterialType(){return ae}loadMaterial(t){const n=this,e=this.json,s=this.extensions,o=e.materials[t];let i;const r={},a=o.extensions||{},c=[];if(a[P.KHR_MATERIALS_UNLIT]){const u=s[P.KHR_MATERIALS_UNLIT];i=u.getMaterialType(),c.push(u.extendParams(r,o,n))}else{const u=o.pbrMetallicRoughness||{};if(r.color=new te(1,1,1),r.opacity=1,Array.isArray(u.baseColorFactor)){const h=u.baseColorFactor;r.color.setRGB(h[0],h[1],h[2],Y),r.opacity=h[3]}u.baseColorTexture!==void 0&&c.push(n.assignTexture(r,"map",u.baseColorTexture,$)),r.metalness=u.metallicFactor!==void 0?u.metallicFactor:1,r.roughness=u.roughnessFactor!==void 0?u.roughnessFactor:1,u.metallicRoughnessTexture!==void 0&&(c.push(n.assignTexture(r,"metalnessMap",u.metallicRoughnessTexture)),c.push(n.assignTexture(r,"roughnessMap",u.metallicRoughnessTexture))),i=this._invokeOne(function(h){return h.getMaterialType&&h.getMaterialType(t)}),c.push(Promise.all(this._invokeAll(function(h){return h.extendMaterialParams&&h.extendMaterialParams(t,r)})))}o.doubleSided===!0&&(r.side=wn);const d=o.alphaMode||ve.OPAQUE;if(d===ve.BLEND?(r.transparent=!0,r.depthWrite=!1):(r.transparent=!1,d===ve.MASK&&(r.alphaTest=o.alphaCutoff!==void 0?o.alphaCutoff:.5)),o.normalTexture!==void 0&&i!==ce&&(c.push(n.assignTexture(r,"normalMap",o.normalTexture)),r.normalScale=new j(1,1),o.normalTexture.scale!==void 0)){const u=o.normalTexture.scale;r.normalScale.set(u,u)}if(o.occlusionTexture!==void 0&&i!==ce&&(c.push(n.assignTexture(r,"aoMap",o.occlusionTexture)),o.occlusionTexture.strength!==void 0&&(r.aoMapIntensity=o.occlusionTexture.strength)),o.emissiveFactor!==void 0&&i!==ce){const u=o.emissiveFactor;r.emissive=new te().setRGB(u[0],u[1],u[2],Y)}return o.emissiveTexture!==void 0&&i!==ce&&c.push(n.assignTexture(r,"emissiveMap",o.emissiveTexture,$)),Promise.all(c).then(function(){const u=new i(r);return o.name&&(u.name=o.name),ie(u,o),n.associations.set(u,{materials:t}),o.extensions&&re(s,u,o),u})}createUniqueName(t){const n=bn.sanitizeNodeName(t||"");return n in this.nodeNamesUsed?n+"_"+ ++this.nodeNamesUsed[n]:(this.nodeNamesUsed[n]=0,n)}loadGeometries(t){const n=this,e=this.extensions,s=this.primitiveCache;function o(r){return e[P.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(r,n).then(function(a){return _t(a,r,n)})}const i=[];for(let r=0,a=t.length;r<a;r++){const c=t[r],d=bs(c),u=s[d];if(u)i.push(u.promise);else{let h;c.extensions&&c.extensions[P.KHR_DRACO_MESH_COMPRESSION]?h=o(c):h=_t(new Xe,c,n),s[d]={primitive:c,promise:h},i.push(h)}}return Promise.all(i)}loadMesh(t){const n=this,e=this.json,s=this.extensions,o=e.meshes[t],i=o.primitives,r=[];for(let a=0,c=i.length;a<c;a++){const d=i[a].material===void 0?Ts(this.cache):this.getDependency("material",i[a].material);r.push(d)}return r.push(n.loadGeometries(i)),Promise.all(r).then(function(a){const c=a.slice(0,a.length-1),d=a[a.length-1],u=[];for(let f=0,T=d.length;f<T;f++){const b=d[f],m=i[f];let A;const E=c[f];if(m.mode===z.TRIANGLES||m.mode===z.TRIANGLE_STRIP||m.mode===z.TRIANGLE_FAN||m.mode===void 0)A=o.isSkinnedMesh===!0?new yn(b,E):new je(b,E),A.isSkinnedMesh===!0&&A.normalizeSkinWeights(),m.mode===z.TRIANGLE_STRIP?A.geometry=yt(A.geometry,Mt):m.mode===z.TRIANGLE_FAN&&(A.geometry=yt(A.geometry,He));else if(m.mode===z.LINES)A=new En(b,E);else if(m.mode===z.LINE_STRIP)A=new Nt(b,E);else if(m.mode===z.LINE_LOOP)A=new Rn(b,E);else if(m.mode===z.POINTS)A=new xn(b,E);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);Object.keys(A.geometry.morphAttributes).length>0&&ws(A,o),A.name=n.createUniqueName(o.name||"mesh_"+t),ie(A,o),m.extensions&&re(s,A,m),n.assignFinalMaterial(A),u.push(A)}for(let f=0,T=u.length;f<T;f++)n.associations.set(u[f],{meshes:t,primitives:f});if(u.length===1)return o.extensions&&re(s,u[0],o),u[0];const h=new Le;o.extensions&&re(s,h,o),n.associations.set(h,{meshes:t});for(let f=0,T=u.length;f<T;f++)h.add(u[f]);return h})}loadCamera(t){let n;const e=this.json.cameras[t],s=e[e.type];if(!s){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return e.type==="perspective"?n=new Ot(Lt.radToDeg(s.yfov),s.aspectRatio||1,s.znear||1,s.zfar||2e6):e.type==="orthographic"&&(n=new _n(-s.xmag,s.xmag,s.ymag,-s.ymag,s.znear,s.zfar)),e.name&&(n.name=this.createUniqueName(e.name)),ie(n,e),Promise.resolve(n)}loadSkin(t){const n=this.json.skins[t],e=[];for(let s=0,o=n.joints.length;s<o;s++)e.push(this._loadNodeShallow(n.joints[s]));return n.inverseBindMatrices!==void 0?e.push(this.getDependency("accessor",n.inverseBindMatrices)):e.push(null),Promise.all(e).then(function(s){const o=s.pop(),i=s,r=[],a=[];for(let c=0,d=i.length;c<d;c++){const u=i[c];if(u){r.push(u);const h=new Pe;o!==null&&h.fromArray(o.array,c*16),a.push(h)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',n.joints[c])}return new Sn(r,a)})}loadAnimation(t){const n=this.json,e=this,s=n.animations[t],o=s.name?s.name:"animation_"+t,i=[],r=[],a=[],c=[],d=[];for(let u=0,h=s.channels.length;u<h;u++){const f=s.channels[u],T=s.samplers[f.sampler],b=f.target,m=b.node,A=s.parameters!==void 0?s.parameters[T.input]:T.input,E=s.parameters!==void 0?s.parameters[T.output]:T.output;b.node!==void 0&&(i.push(this.getDependency("node",m)),r.push(this.getDependency("accessor",A)),a.push(this.getDependency("accessor",E)),c.push(T),d.push(b))}return Promise.all([Promise.all(i),Promise.all(r),Promise.all(a),Promise.all(c),Promise.all(d)]).then(function(u){const h=u[0],f=u[1],T=u[2],b=u[3],m=u[4],A=[];for(let E=0,L=h.length;E<L;E++){const x=h[E],k=f[E],B=T[E],_=b[E],w=m[E];if(x===void 0)continue;x.updateMatrix&&x.updateMatrix();const R=e._createAnimationTracks(x,k,B,_,w);if(R)for(let C=0;C<R.length;C++)A.push(R[C])}return new Ln(o,void 0,A)})}createNodeMesh(t){const n=this.json,e=this,s=n.nodes[t];return s.mesh===void 0?null:e.getDependency("mesh",s.mesh).then(function(o){const i=e._getNodeRef(e.meshCache,s.mesh,o);return s.weights!==void 0&&i.traverse(function(r){if(r.isMesh)for(let a=0,c=s.weights.length;a<c;a++)r.morphTargetInfluences[a]=s.weights[a]}),i})}loadNode(t){const n=this.json,e=this,s=n.nodes[t],o=e._loadNodeShallow(t),i=[],r=s.children||[];for(let c=0,d=r.length;c<d;c++)i.push(e.getDependency("node",r[c]));const a=s.skin===void 0?Promise.resolve(null):e.getDependency("skin",s.skin);return Promise.all([o,Promise.all(i),a]).then(function(c){const d=c[0],u=c[1],h=c[2];h!==null&&d.traverse(function(f){f.isSkinnedMesh&&f.bind(h,Es)});for(let f=0,T=u.length;f<T;f++)d.add(u[f]);return d})}_loadNodeShallow(t){const n=this.json,e=this.extensions,s=this;if(this.nodeCache[t]!==void 0)return this.nodeCache[t];const o=n.nodes[t],i=o.name?s.createUniqueName(o.name):"",r=[],a=s._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(t)});return a&&r.push(a),o.camera!==void 0&&r.push(s.getDependency("camera",o.camera).then(function(c){return s._getNodeRef(s.cameraCache,o.camera,c)})),s._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(t)}).forEach(function(c){r.push(c)}),this.nodeCache[t]=Promise.all(r).then(function(c){let d;if(o.isBone===!0?d=new Mn:c.length>1?d=new Le:c.length===1?d=c[0]:d=new Ve,d!==c[0])for(let u=0,h=c.length;u<h;u++)d.add(c[u]);if(o.name&&(d.userData.name=o.name,d.name=i),ie(d,o),o.extensions&&re(e,d,o),o.matrix!==void 0){const u=new Pe;u.fromArray(o.matrix),d.applyMatrix4(u)}else o.translation!==void 0&&d.position.fromArray(o.translation),o.rotation!==void 0&&d.quaternion.fromArray(o.rotation),o.scale!==void 0&&d.scale.fromArray(o.scale);return s.associations.has(d)||s.associations.set(d,{}),s.associations.get(d).nodes=t,d}),this.nodeCache[t]}loadScene(t){const n=this.extensions,e=this.json.scenes[t],s=this,o=new Le;e.name&&(o.name=s.createUniqueName(e.name)),ie(o,e),e.extensions&&re(n,o,e);const i=e.nodes||[],r=[];for(let a=0,c=i.length;a<c;a++)r.push(s.getDependency("node",i[a]));return Promise.all(r).then(function(a){for(let d=0,u=a.length;d<u;d++)o.add(a[d]);const c=d=>{const u=new Map;for(const[h,f]of s.associations)(h instanceof ke||h instanceof lt)&&u.set(h,f);return d.traverse(h=>{const f=s.associations.get(h);f!=null&&u.set(h,f)}),u};return s.associations=c(o),o})}_createAnimationTracks(t,n,e,s,o){const i=[],r=t.name?t.name:t.uuid,a=[];oe[o.path]===oe.weights?t.traverse(function(h){h.morphTargetInfluences&&a.push(h.name?h.name:h.uuid)}):a.push(r);let c;switch(oe[o.path]){case oe.weights:c=dt;break;case oe.rotation:c=ht;break;case oe.position:case oe.scale:c=ut;break;default:switch(e.itemSize){case 1:c=dt;break;case 2:case 3:default:c=ut;break}break}const d=s.interpolation!==void 0?gs[s.interpolation]:Dt,u=this._getArrayFromAccessor(e);for(let h=0,f=a.length;h<f;h++){const T=new c(a[h]+"."+oe[o.path],n.array,u,d);s.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(T),i.push(T)}return i}_getArrayFromAccessor(t){let n=t.array;if(t.normalized){const e=ze(n.constructor),s=new Float32Array(n.length);for(let o=0,i=n.length;o<i;o++)s[o]=n[o]*e;n=s}return n}_createCubicSplineTrackInterpolant(t){t.createInterpolant=function(e){const s=this instanceof ht?ms:Ft;return new s(this.times,this.values,this.getValueSize()/3,e)},t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function xs(p,t,n){const e=t.attributes,s=new Ue;if(e.POSITION!==void 0){const r=n.json.accessors[e.POSITION],a=r.min,c=r.max;if(a!==void 0&&c!==void 0){if(s.set(new y(a[0],a[1],a[2]),new y(c[0],c[1],c[2])),r.normalized){const d=ze(he[r.componentType]);s.min.multiplyScalar(d),s.max.multiplyScalar(d)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const o=t.targets;if(o!==void 0){const r=new y,a=new y;for(let c=0,d=o.length;c<d;c++){const u=o[c];if(u.POSITION!==void 0){const h=n.json.accessors[u.POSITION],f=h.min,T=h.max;if(f!==void 0&&T!==void 0){if(a.setX(Math.max(Math.abs(f[0]),Math.abs(T[0]))),a.setY(Math.max(Math.abs(f[1]),Math.abs(T[1]))),a.setZ(Math.max(Math.abs(f[2]),Math.abs(T[2]))),h.normalized){const b=ze(he[h.componentType]);a.multiplyScalar(b)}r.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}s.expandByVector(r)}p.boundingBox=s;const i=new Nn;s.getCenter(i.center),i.radius=s.min.distanceTo(s.max)/2,p.boundingSphere=i}function _t(p,t,n){const e=t.attributes,s=[];function o(i,r){return n.getDependency("accessor",i).then(function(a){p.setAttribute(r,a)})}for(const i in e){const r=Ke[i]||i.toLowerCase();r in p.attributes||s.push(o(e[i],r))}if(t.indices!==void 0&&!p.index){const i=n.getDependency("accessor",t.indices).then(function(r){p.setIndex(r)});s.push(i)}return ft.workingColorSpace!==Y&&"COLOR_0"in e&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ft.workingColorSpace}" not supported.`),ie(p,t),xs(p,t,n),Promise.all(s).then(function(){return t.targets!==void 0?As(p,t.targets,n):p})}const Be=new WeakMap;class _s extends Pt{constructor(t){super(t),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(t){return this.decoderPath=t,this}setDecoderConfig(t){return this.decoderConfig=t,this}setWorkerLimit(t){return this.workerLimit=t,this}load(t,n,e,s){const o=new Me(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,i=>{this.parse(i,n,s)},e,s)}parse(t,n,e=()=>{}){this.decodeDracoFile(t,n,null,null,$).catch(e)}decodeDracoFile(t,n,e,s,o=Y,i=()=>{}){const r={attributeIDs:e||this.defaultAttributeIDs,attributeTypes:s||this.defaultAttributeTypes,useUniqueIDs:!!e,vertexColorSpace:o};return this.decodeGeometry(t,r).then(n).catch(i)}decodeGeometry(t,n){const e=JSON.stringify(n);if(Be.has(t)){const a=Be.get(t);if(a.key===e)return a.promise;if(t.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let s;const o=this.workerNextTaskID++,i=t.byteLength,r=this._getWorker(o,i).then(a=>(s=a,new Promise((c,d)=>{s._callbacks[o]={resolve:c,reject:d},s.postMessage({type:"decode",id:o,taskConfig:n,buffer:t},[t])}))).then(a=>this._createGeometry(a.geometry));return r.catch(()=>!0).then(()=>{s&&o&&this._releaseTask(s,o)}),Be.set(t,{key:e,promise:r}),r}_createGeometry(t){const n=new Xe;t.index&&n.setIndex(new we(t.index.array,1));for(let e=0;e<t.attributes.length;e++){const s=t.attributes[e],o=s.name,i=s.array,r=s.itemSize,a=new we(i,r);o==="color"&&(this._assignVertexColorSpace(a,s.vertexColorSpace),a.normalized=!(i instanceof Float32Array)),n.setAttribute(o,a)}return n}_assignVertexColorSpace(t,n){if(n!==$)return;const e=new te;for(let s=0,o=t.count;s<o;s++)e.fromBufferAttribute(t,s).convertSRGBToLinear(),t.setXYZ(s,e.r,e.g,e.b)}_loadLibrary(t,n){const e=new Me(this.manager);return e.setPath(this.decoderPath),e.setResponseType(n),e.setWithCredentials(this.withCredentials),new Promise((s,o)=>{e.load(t,s,void 0,o)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const t=typeof WebAssembly!="object"||this.decoderConfig.type==="js",n=[];return t?n.push(this._loadLibrary("draco_decoder.js","text")):(n.push(this._loadLibrary("draco_wasm_wrapper.js","text")),n.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(n).then(e=>{const s=e[0];t||(this.decoderConfig.wasmBinary=e[1]);const o=Ss.toString(),i=["/* draco decoder */",s,"","/* worker */",o.substring(o.indexOf("{")+1,o.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([i]))}),this.decoderPending}_getWorker(t,n){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const s=new Worker(this.workerSourceURL);s._callbacks={},s._taskCosts={},s._taskLoad=0,s.postMessage({type:"init",decoderConfig:this.decoderConfig}),s.onmessage=function(o){const i=o.data;switch(i.type){case"decode":s._callbacks[i.id].resolve(i);break;case"error":s._callbacks[i.id].reject(i);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+i.type+'"')}},this.workerPool.push(s)}else this.workerPool.sort(function(s,o){return s._taskLoad>o._taskLoad?-1:1});const e=this.workerPool[this.workerPool.length-1];return e._taskCosts[t]=n,e._taskLoad+=n,e})}_releaseTask(t,n){t._taskLoad-=t._taskCosts[n],delete t._callbacks[n],delete t._taskCosts[n]}debug(){console.log("Task load: ",this.workerPool.map(t=>t._taskLoad))}dispose(){for(let t=0;t<this.workerPool.length;++t)this.workerPool[t].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function Ss(){let p,t;onmessage=function(i){const r=i.data;switch(r.type){case"init":p=r.decoderConfig,t=new Promise(function(d){p.onModuleLoaded=function(u){d({draco:u})},DracoDecoderModule(p)});break;case"decode":const a=r.buffer,c=r.taskConfig;t.then(d=>{const u=d.draco,h=new u.Decoder;try{const f=n(u,h,new Int8Array(a),c),T=f.attributes.map(b=>b.array.buffer);f.index&&T.push(f.index.array.buffer),self.postMessage({type:"decode",id:r.id,geometry:f},T)}catch(f){console.error(f),self.postMessage({type:"error",id:r.id,error:f.message})}finally{u.destroy(h)}});break}};function n(i,r,a,c){const d=c.attributeIDs,u=c.attributeTypes;let h,f;const T=r.GetEncodedGeometryType(a);if(T===i.TRIANGULAR_MESH)h=new i.Mesh,f=r.DecodeArrayToMesh(a,a.byteLength,h);else if(T===i.POINT_CLOUD)h=new i.PointCloud,f=r.DecodeArrayToPointCloud(a,a.byteLength,h);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!f.ok()||h.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+f.error_msg());const b={index:null,attributes:[]};for(const m in d){const A=self[u[m]];let E,L;if(c.useUniqueIDs)L=d[m],E=r.GetAttributeByUniqueId(h,L);else{if(L=r.GetAttributeId(h,i[d[m]]),L===-1)continue;E=r.GetAttribute(h,L)}const x=s(i,r,h,m,A,E);m==="color"&&(x.vertexColorSpace=c.vertexColorSpace),b.attributes.push(x)}return T===i.TRIANGULAR_MESH&&(b.index=e(i,r,h)),i.destroy(h),b}function e(i,r,a){const d=a.num_faces()*3,u=d*4,h=i._malloc(u);r.GetTrianglesUInt32Array(a,u,h);const f=new Uint32Array(i.HEAPF32.buffer,h,d).slice();return i._free(h),{array:f,itemSize:1}}function s(i,r,a,c,d,u){const h=u.num_components(),T=a.num_points()*h,b=T*d.BYTES_PER_ELEMENT,m=o(i,d),A=i._malloc(b);r.GetAttributeDataArrayForAllPoints(a,u,m,b,A);const E=new d(i.HEAPF32.buffer,A,T).slice();return i._free(A),{name:c,array:E,itemSize:h}}function o(i,r){switch(r){case Float32Array:return i.DT_FLOAT32;case Int8Array:return i.DT_INT8;case Int16Array:return i.DT_INT16;case Int32Array:return i.DT_INT32;case Uint8Array:return i.DT_UINT8;case Uint16Array:return i.DT_UINT16;case Uint32Array:return i.DT_UINT32}}}class Ls extends On{constructor(t){super(t),this.type=xe}parse(t){const i=function(w,R){switch(w){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(R||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(R||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(R||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(R||""))}},d=`
`,u=function(w,R,C){R=R||1024;let D=w.pos,v=-1,S=0,F="",I=String.fromCharCode.apply(null,new Uint16Array(w.subarray(D,D+128)));for(;0>(v=I.indexOf(d))&&S<R&&D<w.byteLength;)F+=I,S+=I.length,D+=128,I+=String.fromCharCode.apply(null,new Uint16Array(w.subarray(D,D+128)));return-1<v?(w.pos+=S+v+1,F+I.slice(0,v)):!1},h=function(w){const R=/^#\?(\S+)/,C=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,N=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,D=/^\s*FORMAT=(\S+)\s*$/,v=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,S={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let F,I;for((w.pos>=w.byteLength||!(F=u(w)))&&i(1,"no header found"),(I=F.match(R))||i(3,"bad initial token"),S.valid|=1,S.programtype=I[1],S.string+=F+`
`;F=u(w),F!==!1;){if(S.string+=F+`
`,F.charAt(0)==="#"){S.comments+=F+`
`;continue}if((I=F.match(C))&&(S.gamma=parseFloat(I[1])),(I=F.match(N))&&(S.exposure=parseFloat(I[1])),(I=F.match(D))&&(S.valid|=2,S.format=I[1]),(I=F.match(v))&&(S.valid|=4,S.height=parseInt(I[1],10),S.width=parseInt(I[2],10)),S.valid&2&&S.valid&4)break}return S.valid&2||i(3,"missing format specifier"),S.valid&4||i(3,"missing image size specifier"),S},f=function(w,R,C){const N=R;if(N<8||N>32767||w[0]!==2||w[1]!==2||w[2]&128)return new Uint8Array(w);N!==(w[2]<<8|w[3])&&i(3,"wrong scanline width");const D=new Uint8Array(4*R*C);D.length||i(4,"unable to allocate buffer space");let v=0,S=0;const F=4*N,I=new Uint8Array(4),q=new Uint8Array(F);let fe=C;for(;fe>0&&S<w.byteLength;){S+4>w.byteLength&&i(1),I[0]=w[S++],I[1]=w[S++],I[2]=w[S++],I[3]=w[S++],(I[0]!=2||I[1]!=2||(I[2]<<8|I[3])!=N)&&i(3,"bad rgbe scanline format");let Q=0,G;for(;Q<F&&S<w.byteLength;){G=w[S++];const X=G>128;if(X&&(G-=128),(G===0||Q+G>F)&&i(3,"bad scanline data"),X){const U=w[S++];for(let Ee=0;Ee<G;Ee++)q[Q++]=U}else q.set(w.subarray(S,S+G),Q),Q+=G,S+=G}const ye=N;for(let X=0;X<ye;X++){let U=0;D[v]=q[X+U],U+=N,D[v+1]=q[X+U],U+=N,D[v+2]=q[X+U],U+=N,D[v+3]=q[X+U],v+=4}fe--}return D},T=function(w,R,C,N){const D=w[R+3],v=Math.pow(2,D-128)/255;C[N+0]=w[R+0]*v,C[N+1]=w[R+1]*v,C[N+2]=w[R+2]*v,C[N+3]=1},b=function(w,R,C,N){const D=w[R+3],v=Math.pow(2,D-128)/255;C[N+0]=_e.toHalfFloat(Math.min(w[R+0]*v,65504)),C[N+1]=_e.toHalfFloat(Math.min(w[R+1]*v,65504)),C[N+2]=_e.toHalfFloat(Math.min(w[R+2]*v,65504)),C[N+3]=_e.toHalfFloat(1)},m=new Uint8Array(t);m.pos=0;const A=h(m),E=A.width,L=A.height,x=f(m.subarray(m.pos),E,L);let k,B,_;switch(this.type){case Ne:_=x.length/4;const w=new Float32Array(_*4);for(let C=0;C<_;C++)T(x,C*4,w,C*4);k=w,B=Ne;break;case xe:_=x.length/4;const R=new Uint16Array(_*4);for(let C=0;C<_;C++)b(x,C*4,R,C*4);k=R,B=xe;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:E,height:L,data:k,header:A.string,gamma:A.gamma,exposure:A.exposure,type:B}}setDataType(t){return this.type=t,this}load(t,n,e,s){function o(i,r){switch(i.type){case Ne:case xe:i.colorSpace=Y,i.minFilter=le,i.magFilter=le,i.generateMipmaps=!1,i.flipY=!0;break}n&&n(i,r)}return super.load(t,o,e,s)}}const St=2;class Ms{constructor(){this.container=document.getElementById("game-container"),this.loadingScreen=document.getElementById("loading-screen"),this.scene=null,this.camera=null,this.renderer=null,this.controls=null,this.gltfLoader=null,this.dracoLoader=null,this.textureLoader=null,this.rgbeLoader=null,this.loadedAssets=[],this.textureCache=new Map,this.masterRoadMaterial=null,this.roadPieces=[],this.occupiedCells=new Set,this.lastCurveDir=0,this.sameDirCount=0,this.straightsSinceCurve=99,this.activeSegments=[],this.spawnAheadDistance=100,this.despawnBehindDistance=10,this.infiniteRoadEnabled=!0,this.gridHelper=null,this.axesHelper=null,this.car=null,this.carSpeed=5,this.currentSegmentIndex=0,this.currentPathT=0,this.segmentPaths=[],this.isCarMoving=!1,this.lastFrameTime=0,this.debugPaths=!1,this.carTargetQuaternion=new V,this.chaseCamEnabled=!0,this.chaseCamOffset=new y(0,3,-5),this.chaseCamLookAhead=1.5,this.chaseCamSmoothSpeed=4,this.chaseCamRotationSmooth=3,this.currentCamPos=new y,this.currentCamLookAt=new y,this.smoothedTangent=new y(0,0,-1),this.buildingTemplates=[],this.spawnedBuildings=[],this.cursorOverflowL=0,this.cursorOverflowR=0}async init(){this.setupRenderer(),this.setupScene(),this.setupLoaders(),this.setupLighting(),this.setupControls(),this.setupHelpers();try{const t=await this.loadHDR("/kloofendal_48d_partly_cloudy_puresky_1k.hdr");this.scene.environment=t,console.log("Environment map loaded")}catch{console.warn("HDR environment not found, using default lighting")}this.hideLoadingScreen(),this.animate(),window.loadBuilding=(t,n)=>this.loadBuilding(t,n),window.loadRoad=(t,n)=>this.loadRoad(t,n),window.spawn=(t,n,e,s)=>this.spawn(t,n,e,s),window.clear=()=>this.clearAll(),window.list=()=>this.listAssets(),window.toggleGrid=()=>this.toggleGrid(),window.generateRoad=t=>this.generateRoad(t),window.clearRoad=()=>this.clearRoad(),window.startCar=()=>this.startCar(),window.stopCar=()=>this.stopCar(),window.setCarSpeed=t=>{this.carSpeed=t,console.log(`Car speed: ${t}`)},window.debugPaths=(t=!0)=>{this.debugPaths=t,console.log(`Debug paths: ${t}`)},window.showPaths=()=>this.visualizeAllPaths(),window.toggleChaseCamera=()=>this.toggleChaseCamera(),window.addCarAxes=()=>this.addCarAxes(),window.generateBuildings=()=>this.generateBuildings(),window.clearBuildings=()=>this.clearBuildings(),window.initInfiniteRoad=t=>this.initInfiniteRoad(t),window.toggleInfiniteRoad=()=>{this.infiniteRoadEnabled=!this.infiniteRoadEnabled,console.log(`Infinite road: ${this.infiniteRoadEnabled?"ON":"OFF"}`)},await this.loadBuildingFacade("oldbuilding",{glbPath:"/Building%20Facade/OldBuildingfacadenomaterial.glb",lightMapPath:"/Building%20Facade/oldbuildingfacade_baked.webp",uvChannel:1}),await this.loadBuildingFacade("building148",{glbPath:"/Building%20Facade/building%20148/building148.glb",lightMapPath:"/Building%20Facade/building%20148/building148_bakedtexture.webp",uvChannel:1}),await this.initInfiniteRoad(5),await this.startCar(),console.log("%c Infinite Procedural City Ready ","background: #0066cc; color: white; padding: 4px 8px; border-radius: 4px;"),console.log("Keys: [C] Toggle Camera | [G] Toggle Grid | [Space] Pan"),console.log("Commands:"),console.log("  initInfiniteRoad(5)     - Reset infinite road with N initial segments"),console.log("  toggleInfiniteRoad()    - Toggle infinite spawning on/off"),console.log("  startCar() / stopCar()  - Control car movement"),console.log("  setCarSpeed(15)         - Set car speed (units/sec)")}setupRenderer(){this.renderer=new Dn({antialias:!0,powerPreference:"high-performance"}),this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.renderer.outputColorSpace=$,this.renderer.toneMapping=vn,this.renderer.shadowMap.enabled=!1,this.container.appendChild(this.renderer.domElement),window.addEventListener("resize",()=>this.onResize())}setupScene(){this.scene=new Fn,this.scene.background=new te(8900331),this.scene.fog=new Bn(8900331,200,600),this.camera=new Ot(45,window.innerWidth/window.innerHeight,.1,1e3),this.camera.position.set(50,40,50),this.camera.lookAt(0,0,0)}setupLoaders(){this.dracoLoader=new _s,this.dracoLoader.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.6/"),this.dracoLoader.setDecoderConfig({type:"js"}),this.gltfLoader=new Vn,this.gltfLoader.setDRACOLoader(this.dracoLoader),this.textureLoader=new It,this.rgbeLoader=new Ls}setupLighting(){const t=new Hn(16777215,.5);this.scene.add(t);const n=new Ct(16777215,1.5);n.position.set(50,100,50),this.scene.add(n);const e=new Gn(8900331,4473890,.6);this.scene.add(e)}setupControls(){this.controls=new zn(this.camera,this.renderer.domElement),this.controls.enableDamping=!0,this.controls.dampingFactor=.1,this.controls.screenSpacePanning=!0,this.controls.minDistance=1,this.controls.maxDistance=500,this.controls.mouseButtons={LEFT:W.ROTATE,MIDDLE:W.PAN,RIGHT:W.ROTATE},document.addEventListener("keydown",t=>{t.code==="Space"&&(t.preventDefault(),this.controls.mouseButtons.LEFT=W.PAN),t.code==="KeyG"&&this.toggleGrid(),t.code==="KeyC"&&this.toggleChaseCamera()}),document.addEventListener("keyup",t=>{t.code==="Space"&&(this.controls.mouseButtons.LEFT=W.ROTATE)})}setupHelpers(){this.gridHelper=new jn(200,200,16777215,16777215),this.gridHelper.material.opacity=.15,this.gridHelper.material.transparent=!0,this.scene.add(this.gridHelper),this.axesHelper=new pt(10),this.scene.add(this.axesHelper),console.log("%c Three.js Axes: RED = +X | GREEN = +Y | BLUE = +Z ","background: #333; color: #fff; padding: 4px;")}addCarAxes(){if(this.car){const t=new pt(3);this.car.add(t),console.log("Car axes added: RED = +X | GREEN = +Y | BLUE = +Z")}}loadHDR(t){return new Promise((n,e)=>{this.rgbeLoader.load(t,s=>{s.mapping=Un,n(s)},void 0,e)})}async loadTexture(t,n={}){return this.textureCache.has(t)?this.textureCache.get(t):new Promise((e,s)=>{this.textureLoader.load(t,o=>{n.colorSpace==="srgb"&&(o.colorSpace=$),o.flipY=n.flipY??!1,o.needsUpdate=!0,this.textureCache.set(t,o),e(o)},void 0,s)})}async loadRoadMaterial(){if(this.masterRoadMaterial)return this.masterRoadMaterial;console.log("Loading road PBR textures...");const t="/Road%20Pack/Textures%20compressed/WebP%20Normal+AO/initialShadingGroup_",n=this.renderer.capabilities.getMaxAnisotropy(),e=(s,o=!1)=>(s.flipY=!1,s.minFilter=be,s.magFilter=le,s.anisotropy=n,s.generateMipmaps=!0,o&&(s.colorSpace=$),s.needsUpdate=!0,s);try{const[s,o,i,r,a,c]=await Promise.all([this.loadTexture(t+"Base_Color.webp"),this.loadTexture(t+"Normal_DirectX.webp"),this.loadTexture(t+"Roughness.webp"),this.loadTexture(t+"Metallic.webp"),this.loadTexture(t+"Mixed_AO.webp"),this.loadTexture(t+"Height.webp")]);return e(s,!0),e(o),e(i),e(r),e(a),e(c),this.masterRoadMaterial=new ae({map:s,normalMap:o,roughnessMap:i,metalnessMap:r,aoMap:a,displacementMap:c,displacementScale:0,envMap:this.scene.environment,envMapIntensity:.5}),console.log("Road material created with PBR textures"),this.masterRoadMaterial}catch(s){return console.error("Failed to load road textures:",s),this.masterRoadMaterial=new ae({color:3355443}),this.masterRoadMaterial}}async loadBuilding(t,n={}){const e=n.glbPath||`/Env%20Assets/${t}.glb`,s=n.lightMapPath||`/Env%20Assets/Baked%20Textures/lightmapUV_${t}.webp`,o=n.uvChannel??1;console.log(`Loading building: ${t}`),console.log(`  GLB: ${e}`),console.log(`  Texture: ${s} (UV${o})`);try{const r=(await new Promise((c,d)=>{this.gltfLoader.load(e,c,void 0,d)})).scene;let a=null;try{a=await this.loadTexture(s,{colorSpace:"srgb"}),a.channel=o,a.minFilter=be,a.magFilter=le,a.anisotropy=this.renderer.capabilities.getMaxAnisotropy(),a.generateMipmaps=!0,a.needsUpdate=!0,console.log(`  Texture loaded: ${a.image.width}x${a.image.height}, channel=${o}, anisotropy=${a.anisotropy}`)}catch{console.warn(`Texture not found: ${s}`)}return r.traverse(c=>{if(c.isMesh){c.castShadow=!1,c.receiveShadow=!1;const d=c.geometry;d.attributes.uv1&&!d.attributes.uv2&&d.setAttribute("uv2",d.attributes.uv1);const u=c.material;((u==null?void 0:u.name)||"").includes("GlassCyanC")&&this.scene.environment?c.material=new ae({color:8965358,metalness:.95,roughness:.05,envMap:this.scene.environment,envMapIntensity:1}):a&&(c.material=new ce({map:a}))}}),r.visible=!1,this.scene.add(r),this.loadedAssets.push({name:t,template:r,instances:[]}),console.log(`Building loaded: ${t}`),r}catch(i){return console.error(`Failed to load building: ${t}`,i),null}}async loadRoad(t,n={}){const e=n.glbPath||`/Road%20Pack/Road%20Pieces/${t}.glb`;console.log(`Loading road: ${t}`),await this.loadRoadMaterial();try{const o=(await new Promise((a,c)=>{this.gltfLoader.load(e,a,void 0,c)})).scene;o.traverse(a=>{a.isMesh&&(a.castShadow=!1,a.receiveShadow=!1,a.material=this.masterRoadMaterial)}),o.visible=!1,this.scene.add(o),this.loadedAssets.push({name:t,template:o,instances:[]});const r=new Ue().setFromObject(o).getSize(new y);return console.log(`Road loaded: ${t} (${r.x.toFixed(1)} x ${r.z.toFixed(1)})`),o}catch(s){return console.error(`Failed to load road: ${t}`,s),null}}spawn(t,n=0,e=0,s=0){const o=this.loadedAssets.find(r=>r.name===t);if(!o)return console.error(`Asset not loaded: ${t}`),null;const i=o.template.clone(!0);return i.visible=!0,i.traverse(r=>{r.visible=!0}),i.position.set(n,0,e),i.rotation.y=s%4*(Math.PI/2),this.scene.add(i),o.instances.push(i),i}listAssets(){console.log("Loaded assets:"),this.loadedAssets.forEach(t=>console.log(`  ${t.name} (${t.instances.length} instances)`))}clearAll(){this.loadedAssets.forEach(t=>{t.instances.forEach(n=>{this.scene.remove(n)}),t.instances=[],this.scene.remove(t.template)}),this.loadedAssets=[],console.log("Cleared all assets")}toggleGrid(){this.gridHelper.visible=!this.gridHelper.visible}findSocketOut(t){let n=null;return t.traverse(e=>{(e.name.toLowerCase().includes("socket_out")||e.name.toLowerCase().includes("socket"))&&(n=e)}),n}getSocketTransform(t){const n=this.findSocketOut(t);if(!n)return console.warn("No socket_out found in piece"),{position:new y,quaternion:new V};n.updateMatrixWorld(!0);const e=new y,s=new V;return n.getWorldPosition(e),n.getWorldQuaternion(s),{position:e,quaternion:s}}cellKey(t,n){const e=Math.round(t/St),s=Math.round(n/St);return`${e},${s}`}sampleRoadCells(t){const n=[],e=this.findSocketOut(t);if(!e)return n;const s=new y;t.getWorldPosition(s),e.updateMatrixWorld(!0);const o=new y;e.getWorldPosition(o);const i=s.distanceTo(o),r=Math.max(1,Math.ceil(i));for(let a=0;a<=r;a++){const c=a/r,d=s.x+(o.x-s.x)*c,u=s.z+(o.z-s.z)*c;n.push(this.cellKey(d,u))}return n}checkCollision(t,n=new Set){for(const e of t)if(this.occupiedCells.has(e)&&!n.has(e))return!0;return!1}trySpawnRoad(t,n=!1,e=null){const s=this.loadedAssets.find(c=>c.name===t);if(!s)return console.warn(`Road not loaded: ${t}`),null;const o=s.template.clone(!0);if(o.visible=!0,o.traverse(c=>{c.visible=!0}),n&&o.scale.set(-1,1,1),!e)o.position.set(0,0,0),o.quaternion.identity();else{const{position:c,quaternion:d}=this.getSocketTransform(e);o.position.copy(c),o.quaternion.copy(d)}o.updateMatrixWorld(!0);const i=this.sampleRoadCells(o),r=new Set,a=Math.min(2,this.roadPieces.length);for(let c=this.roadPieces.length-a;c<this.roadPieces.length;c++)c>=0&&this.sampleRoadCells(this.roadPieces[c]).forEach(u=>r.add(u));return this.checkCollision(i,r)?null:(this.scene.add(o),s.instances.push(o),this.roadPieces.push(o),i.forEach(c=>this.occupiedCells.add(c)),o)}buildCandidates(){const t=[];return t.push({name:"road_long",type:"straight",mirror:!1}),t.push({name:"road_short",type:"straight",mirror:!1}),t}shuffle(t){for(let n=t.length-1;n>0;n--){const e=Math.floor(Math.random()*(n+1));[t[n],t[e]]=[t[e],t[n]]}return t}updateDirectionTracking(t,n=0){t==="straight"?this.straightsSinceCurve++:t==="curve"&&(n===this.lastCurveDir?this.sameDirCount++:(this.sameDirCount=1,this.lastCurveDir=n),this.straightsSinceCurve=0)}async generateRoad(t=20){console.log(`Generating road with ${t} pieces...`);const n=["road_long","road_short"];for(const e of n)this.loadedAssets.find(s=>s.name===e)||await this.loadRoad(e);this.clearRoad();for(let e=0;e<t;e++){const s=this.roadPieces.length>0?this.roadPieces[this.roadPieces.length-1]:null,o=this.shuffle(this.buildCandidates());let i=!1;for(const r of o)if(this.trySpawnRoad(r.name,r.mirror,s)){this.updateDirectionTracking(r.type,r.dir||0),i=!0;break}if(!i){console.warn(`Could not place piece ${e+1}, stopping generation`);break}}console.log(`Road generated: ${this.roadPieces.length} pieces`),this.buildSegmentPaths(),this.startCar(),this.buildingTemplates.length>0&&this.generateBuildings()}clearRoad(){this.roadPieces.forEach(t=>{this.scene.remove(t)}),this.roadPieces=[],this.segmentPaths=[],this.occupiedCells.clear(),this.lastCurveDir=0,this.sameDirCount=0,this.straightsSinceCurve=99,this.currentSegmentIndex=0,this.currentPathT=0,this.clearBuildings(),this.activeSegments.forEach(t=>{this.disposeSegment(t)}),this.activeSegments=[],console.log("Road cleared")}async initInfiniteRoad(t=5){console.log("Initializing infinite road..."),this.clearRoad();const n=["road_long","road_short"];for(const e of n)this.loadedAssets.find(s=>s.name===e)||await this.loadRoad(e);for(let e=0;e<t;e++)this.spawnNextSegment();this.buildSegmentPaths(),console.log(`Infinite road initialized with ${this.activeSegments.length} segments`)}spawnNextSegment(){const t=["road_long","road_short"],n=t[Math.floor(Math.random()*t.length)],e=this.loadedAssets.find(r=>r.name===n);if(!e)return console.warn(`Road not loaded: ${n}`),null;const s=e.template.clone(!0);s.visible=!0,s.traverse(r=>{r.visible=!0});const o=this.activeSegments[this.activeSegments.length-1];if(o){const{position:r,quaternion:a}=this.getSocketTransform(o.road);s.position.copy(r),s.quaternion.copy(a)}else s.position.set(0,0,0),s.quaternion.identity();s.updateMatrixWorld(!0),this.scene.add(s);const i={road:s,buildings:[],path:null};return this.spawnBuildingsForSegment(i),i.path=this.extractCarPath(s),this.activeSegments.push(i),this.roadPieces.push(s),this.segmentPaths.push(i.path),i}spawnBuildingsForSegment(t){if(this.buildingTemplates.length===0)return;const n=t.road,e=this.findPathMarkers(n),s=this.getMarkerTransform(e.pathL.start),o=this.getMarkerTransform(e.pathL.end),i=this.getMarkerTransform(e.pathR.start),r=this.getMarkerTransform(e.pathR.end);if(s&&o){const a=this.spawnBuildingsAlongPathForSegment(s,o);t.buildings.push(...a)}if(i&&r){const a=this.spawnBuildingsAlongPathForSegment(i,r);t.buildings.push(...a)}}spawnBuildingsAlongPathForSegment(t,n){const e=[];if(!t||!n)return e;const s=new y().subVectors(n.position,t.position),o=s.length();s.normalize();const i=t.quaternion;let r=0;for(;r<o;){const a=this.buildingTemplates[Math.floor(Math.random()*this.buildingTemplates.length)],c=a.width,d=new y().copy(t.position).addScaledVector(s,r),u=a.model.clone(!0);u.visible=!0,u.traverse(f=>{f.visible=!0}),u.position.copy(d),u.quaternion.copy(i),this.scene.add(u),e.push(u);const h=.01+Math.random()*.09;r+=c+h}return e}getDistanceToRoadEnd(){if(!this.car||this.activeSegments.length===0)return 1/0;const t=this.activeSegments[this.activeSegments.length-1],{position:n}=this.getSocketTransform(t.road);return this.car.position.distanceTo(n)}updateInfiniteRoadSpawning(){if(!this.infiniteRoadEnabled||!this.car)return;this.getDistanceToRoadEnd()<this.spawnAheadDistance&&this.spawnNextSegment()&&console.log(`Spawned new segment, total: ${this.activeSegments.length}`)}updateInfiniteRoadCleanup(){if(!this.infiniteRoadEnabled||!this.car||this.activeSegments.length<=3)return;const t=this.activeSegments[0];if(!t)return;const n=new y;t.road.getWorldPosition(n),this.car.position.distanceTo(n)>this.despawnBehindDistance&&this.currentSegmentIndex>0&&this.removeOldestSegment()}removeOldestSegment(){const t=this.activeSegments.shift();if(!t)return;const n=this.roadPieces.indexOf(t.road);n!==-1&&(this.roadPieces.splice(n,1),this.segmentPaths.splice(n,1),this.currentSegmentIndex=Math.max(0,this.currentSegmentIndex-1)),this.disposeSegment(t),console.log(`Removed oldest segment, remaining: ${this.activeSegments.length}`)}disposeSegment(t){t.buildings.forEach(n=>{this.scene.remove(n),n.traverse(e=>{e.isMesh&&(e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(s=>s.dispose()):e.material.dispose()))})}),this.scene.remove(t.road),t.road.traverse(n=>{n.isMesh&&n.geometry&&n.geometry.dispose()})}extractCarPath(t){const n=new y;t.getWorldPosition(n);const e=this.findSocketOut(t);if(!e)return console.warn("No socket_out found"),this.createFallbackPath(t);e.updateMatrixWorld(!0);const s=new y;e.getWorldPosition(s);const o=new V;e.getWorldQuaternion(o);const i=new V;t.getWorldQuaternion(i);const r=i.clone().invert(),a=o.clone().multiply(r),d=new mt().setFromQuaternion(a).y,u=.1;n.y=u,s.y=u;const h=[],f=12;if(Math.abs(d)<.1){for(let b=0;b<=f;b++){const m=b/f,A=new y().lerpVectors(n,s,m);h.push(A)}console.log(`Straight path: ${h.length} points`)}else{const b=new y().lerpVectors(n,s,.5),m=n.distanceTo(s),A=m/(2*Math.sin(Math.abs(d)/2)),E=new y().subVectors(s,n).normalize(),L=new y(-E.z,0,E.x);d>0&&L.negate();const x=A-Math.sqrt(A*A-m/2*(m/2)),k=b.clone().add(L.clone().multiplyScalar(A-x));k.y=u;const B=Math.atan2(n.z-k.z,n.x-k.x);for(let _=0;_<=f;_++){const w=_/f,R=B-d*w,C=new y(k.x+A*Math.cos(R),u,k.z+A*Math.sin(R));h.push(C)}console.log(`Curved path (${(d*180/Math.PI).toFixed(1)}): ${h.length} points`)}return new gt(h,!1,"centripetal")}createFallbackPath(t){const n=new y;t.getWorldPosition(n);const e=this.findSocketOut(t),s=new y;return e?(e.updateMatrixWorld(!0),e.getWorldPosition(s)):s.copy(n).add(new y(0,0,10)),new gt([n,s],!1,"catmullrom",.5)}buildSegmentPaths(){this.segmentPaths=[];for(const t of this.roadPieces){const n=this.extractCarPath(t);this.segmentPaths.push(n)}console.log(`Built ${this.segmentPaths.length} segment paths`)}visualizeAllPaths(){this.scene.children.filter(t=>t.userData.isPathViz).forEach(t=>this.scene.remove(t));for(const t of this.segmentPaths){const n=t.getPoints(50),e=new Xe().setFromPoints(n),s=new kt({color:16711935,linewidth:2}),o=new Nt(e,s);o.userData.isPathViz=!0,this.scene.add(o)}console.log("Paths visualized (magenta lines)")}async createCar(){this.car&&this.scene.remove(this.car);const t=new Le,n=new je(new Tt(.35,.15,.75),new ae({color:2241535,metalness:.6,roughness:.4}));n.position.y=.1,t.add(n);const e=new je(new Tt(.3,.1,.4),new ae({color:2241535,metalness:.6,roughness:.4}));return e.position.set(0,.225,-.05),t.add(e),this.car=t,this.scene.add(this.car),console.log("Placeholder car created"),this.car}async startCar(){this.segmentPaths.length===0&&this.buildSegmentPaths(),this.car||await this.createCar(),this.currentSegmentIndex=0,this.currentPathT=0,this.isCarMoving=!0,this.updateCarPosition(),this.chaseCamEnabled&&(this.controls.enabled=!1,this.setupChaseCamera()),console.log("Car started")}stopCar(){this.isCarMoving=!1,console.log("Car stopped")}updateCarPosition(){if(!this.car||this.segmentPaths.length===0)return;const t=this.segmentPaths[this.currentSegmentIndex];if(!t)return;const n=t.getPointAt(this.currentPathT);this.car.position.lerp(n,.15);const e=t.getTangentAt(this.currentPathT),s=n.clone().add(e),o=new Ve;o.position.copy(n),o.lookAt(s),this.carTargetQuaternion.copy(o.quaternion),this.car.quaternion.slerp(this.carTargetQuaternion,.08)}updateCar(t){if(!this.isCarMoving||this.segmentPaths.length===0)return;const n=this.segmentPaths[this.currentSegmentIndex];if(!n)return;const e=n.getLength(),s=this.carSpeed/e;this.currentPathT+=s*t,this.currentPathT>=1&&(this.currentPathT=0,this.currentSegmentIndex++,this.currentSegmentIndex>=this.segmentPaths.length&&(this.currentSegmentIndex=0,console.log("Car looped to start"))),this.updateCarPosition(),this.chaseCamEnabled&&this.updateChaseCamera()}setupChaseCamera(){if(!this.car)return;this.camera.up.set(0,1,0);const t=this.segmentPaths[this.currentSegmentIndex];if(!t)return;const n=t.getTangentAt(this.currentPathT);n.y=0,n.normalize();const e=.5;this.camera.position.copy(this.car.position).addScaledVector(n,-1.5).add(new y(0,e,0));const s=new y().copy(this.car.position).addScaledVector(n,3);this.camera.lookAt(s.x,.1,s.z),console.log("Chase camera enabled - positioned behind car")}updateChaseCamera(){if(!this.car)return;const t=this.segmentPaths[this.currentSegmentIndex];if(!t)return;const n=t.getTangentAt(this.currentPathT);n.y=0,n.normalize(),this.smoothedTangent.lerp(n,.1),this.smoothedTangent.normalize();const e=.5,s=new y().copy(this.car.position).addScaledVector(this.smoothedTangent,-1.5).add(new y(0,e,0));this.camera.position.lerp(s,.3);const o=new y().copy(this.car.position).addScaledVector(this.smoothedTangent,3);this.camera.up.set(0,1,0),this.camera.lookAt(o.x,.1,o.z)}detachChaseCamera(){this.camera.position.set(50,40,50),this.camera.lookAt(0,0,0),console.log("Chase camera detached")}toggleChaseCamera(){this.chaseCamEnabled=!this.chaseCamEnabled,this.controls.enabled=!this.chaseCamEnabled,this.chaseCamEnabled?this.car&&this.setupChaseCamera():(this.detachChaseCamera(),this.controls.update()),console.log(`Chase camera: ${this.chaseCamEnabled?"ON":"OFF"}`)}async loadBuildingFacade(t,n={}){const e=n.glbPath,s=n.lightMapPath,o=n.uvChannel??1;console.log(`Loading building facade: ${t}`);try{const r=(await new Promise((h,f)=>{this.gltfLoader.load(e,h,void 0,f)})).scene;let a=null;if(s)try{a=await this.loadTexture(s,{colorSpace:"srgb"}),a.channel=o,a.minFilter=be,a.magFilter=le,a.anisotropy=this.renderer.capabilities.getMaxAnisotropy(),a.generateMipmaps=!0,a.needsUpdate=!0}catch{console.warn(`Texture not found: ${s}`)}r.traverse(h=>{if(h.isMesh){h.castShadow=!1,h.receiveShadow=!1;const f=h.geometry;o===1&&f.attributes.uv1&&f.setAttribute("uv",f.attributes.uv1),a&&(h.material=new ce({map:a}))}});const d=new Ue().setFromObject(r).getSize(new y);r.visible=!1,this.scene.add(r);const u={name:t,model:r,width:d.x,height:d.y,depth:d.z};return this.buildingTemplates.push(u),console.log(`Building facade loaded: ${t} (W:${d.x.toFixed(2)} H:${d.y.toFixed(2)} D:${d.z.toFixed(2)})`),u}catch(i){return console.error(`Failed to load building facade: ${t}`,i),null}}findPathMarkers(t){const n={pathL:{start:null,end:null},pathR:{start:null,end:null}};return t.traverse(e=>{const s=e.name.toLowerCase();s.includes("path_l_start")||s.includes("pathl_start")?n.pathL.start=e:s.includes("path_l_end")||s.includes("pathl_end")?n.pathL.end=e:s.includes("path_r_start")||s.includes("pathr_start")?n.pathR.start=e:(s.includes("path_r_end")||s.includes("pathr_end"))&&(n.pathR.end=e)}),n}getMarkerTransform(t){if(!t)return null;t.updateMatrixWorld(!0);const n=new y;t.getWorldPosition(n);const e=new V;t.getWorldQuaternion(e);const s=new y(0,1,0);return s.applyQuaternion(e),s.y=0,s.normalize(),{position:n,quaternion:e,forward:s}}spawnBuildingAtCursor(t,n,e){const s=t.model.clone(!0);return s.visible=!0,s.traverse(o=>{o.visible=!0}),s.position.copy(n),s.quaternion.copy(e),this.scene.add(s),this.spawnedBuildings.push(s),s}generateBuildingsAlongPath(t,n,e=0){if(!t||!n)return 0;const s=new y().subVectors(n.position,t.position),o=s.length();s.normalize();const i=t.quaternion;let r=e;for(;r<o;){const c=this.buildingTemplates[Math.floor(Math.random()*this.buildingTemplates.length)];if(!c)break;const d=c.width,u=new y().copy(t.position).addScaledVector(s,r);this.spawnBuildingAtCursor(c,u,i);const h=.01+Math.random()*.09;r+=d+h}const a=r-o;return a>0?a:0}isStraightRoad(t){const n=this.findSocketOut(t);if(!n)return!0;n.updateMatrixWorld(!0);const e=new V;n.getWorldQuaternion(e);const s=new V;t.getWorldQuaternion(s);const o=s.clone().invert(),i=e.clone().multiply(o),r=new mt().setFromQuaternion(i);return Math.abs(r.y)<.1}generateBuildings(){console.log("Generating buildings..."),this.clearBuildings(),this.cursorOverflowL=0,this.cursorOverflowR=0;let t=0;for(const n of this.roadPieces){if(!this.isStraightRoad(n)){this.cursorOverflowL=0,this.cursorOverflowR=0;continue}const e=this.findPathMarkers(n),s=this.getMarkerTransform(e.pathL.start),o=this.getMarkerTransform(e.pathL.end),i=this.getMarkerTransform(e.pathR.start),r=this.getMarkerTransform(e.pathR.end);if(s&&o){const a=this.spawnedBuildings.length;this.cursorOverflowL=this.generateBuildingsAlongPath(s,o,this.cursorOverflowL),t+=this.spawnedBuildings.length-a}if(i&&r){const a=this.spawnedBuildings.length;this.cursorOverflowR=this.generateBuildingsAlongPath(i,r,this.cursorOverflowR),t+=this.spawnedBuildings.length-a}}console.log(`Buildings generated: ${t} buildings`)}clearBuildings(){this.spawnedBuildings&&this.spawnedBuildings.forEach(t=>{this.scene.remove(t)}),this.spawnedBuildings=[],this.cursorOverflowL=0,this.cursorOverflowR=0}onResize(){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(window.innerWidth,window.innerHeight)}hideLoadingScreen(){this.loadingScreen.classList.add("hidden"),setTimeout(()=>{this.loadingScreen.style.display="none"},500)}animate(){requestAnimationFrame(()=>this.animate());const t=performance.now(),n=(t-(this.lastFrameTime||t))/1e3;this.lastFrameTime=t,this.updateCar(n),this.updateInfiniteRoadSpawning(),this.updateInfiniteRoadCleanup(),this.chaseCamEnabled||this.controls.update(),this.renderer.render(this.scene,this.camera)}}const Bt=new Ms;Bt.init().catch(console.error);window.viewer=Bt;
//# sourceMappingURL=index-LHae8dE2.js.map
